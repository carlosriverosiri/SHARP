---
import Icon from "./Icon.astro";
---

<div id="quickPromptRoot" class="qp-root" style="display: none;">
  <button id="quickPromptFab" class="qp-fab" title="Snabbprompt (Ctrl+Shift+D)">
    <Icon name="edit" size={20} />
  </button>
  <div id="quickPromptModal" class="qp-modal">
    <div class="qp-modal-header">
      <div class="qp-modal-title">Snabbprompt</div>
      <div class="qp-modal-header-actions">
        <button class="qp-icon-btn" id="quickPromptCopyInline" title="Kopiera">
          <Icon name="copy" size={16} />
        </button>
        <button class="qp-icon-btn" id="quickPromptClear" title="Rensa">
          <Icon name="trash" size={16} />
        </button>
        <button class="qp-icon-btn" id="quickPromptClose" title="Stäng">
          <Icon name="x" size={16} />
        </button>
      </div>
    </div>
    <div class="qp-modal-body">
      <div class="qp-textarea-wrap">
        <textarea id="quickPromptInput" class="qp-textarea" placeholder="Diktera eller skriv en prompt för Cursor..."></textarea>
        <button id="quickPromptMic" class="qp-mic" title="Diktera">
          <Icon name="mic" size={18} />
        </button>
      </div>
      <div id="quickPromptStatus" class="qp-status"></div>
    </div>
    <div class="qp-modal-actions">
      <button id="quickPromptStructure" class="qp-btn qp-btn-warning qp-btn-lg qp-structure-btn">
        <Icon name="file-text" size={16} />
        Strukturera prompten
      </button>
      <button id="quickPromptCopy" class="qp-btn qp-btn-secondary">
        <Icon name="copy" size={16} />
        Kopiera
      </button>
    </div>
  </div>
</div>

<style is:global>
  .qp-root {
    position: fixed;
    right: 24px;
    top: 24px;
    z-index: 9999;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 12px;
  }
  .qp-root.draggable {
    cursor: move;
  }
  .qp-modal-header {
    cursor: move;
    user-select: none;
  }
  .qp-fab {
    width: 54px;
    height: 54px;
    border-radius: 999px;
    background: #2563eb;
    color: white;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);
    border: none;
    cursor: pointer;
  }
  .qp-modal {
    width: min(640px, 90vw);
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 16px;
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.18);
    padding: 16px;
    display: none;
  }
  .qp-modal.open { display: block; }
  .qp-modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 8px;
  }
  .qp-modal-header-actions {
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }
  .qp-modal-title {
    font-weight: 700;
    font-size: 1rem;
  }
  .qp-icon-btn {
    width: 32px;
    height: 32px;
    border-radius: 8px;
    border: 1px solid #e5e7eb;
    background: white;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
  }
  .qp-textarea-wrap {
    position: relative;
  }
  .qp-textarea {
    width: 100%;
    min-height: 160px;
    border: 1px solid #e5e7eb;
    background: #f3f4f6;
    border-radius: 10px;
    padding: 14px 64px 14px 14px;
    font-size: 0.95rem;
    line-height: 1.6;
    resize: vertical;
  }
  .qp-mic {
    position: absolute;
    right: 12px;
    bottom: 12px;
    width: 44px;
    height: 44px;
    border-radius: 999px;
    background: white;
    border: 1px solid #e5e7eb;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
  }
  .qp-mic.recording {
    background: #ef4444;
    border-color: #ef4444;
    color: white;
    box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.2);
  }
  .qp-status {
    font-size: 12px;
    color: #6b7280;
    margin-top: 6px;
    min-height: 16px;
  }
  .qp-modal-actions {
    margin-top: 12px;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: flex-end;
  }
  .qp-structure-btn {
    font-weight: 700;
  }
  .qp-btn {
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    font-size: 0.875rem;
    font-weight: 600;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 0.375rem;
    border: 1px solid transparent;
    background: white;
  }
  .qp-btn svg { width: 1rem; height: 1rem; }
  .qp-btn-warning {
    background: #f59e0b;
    color: white;
  }
  .qp-btn-warning:hover { background: #d97706; }
  .qp-btn-secondary {
    background: white;
    color: #1f2937;
    border-color: #e5e7eb;
  }
  .qp-btn-secondary:hover { background: #f3f4f6; }
  .qp-btn-lg {
    padding: 0.75rem 1.25rem;
    font-size: 1rem;
  }
</style>

<script is:inline>
  (function() {
    const shouldEnable =
      window.location.hostname === 'localhost' ||
      window.location.hostname === '127.0.0.1';
    const root = document.getElementById('quickPromptRoot');
    if (!shouldEnable || !root) return;
    root.style.display = 'flex';

    const fab = document.getElementById('quickPromptFab');
    const modal = document.getElementById('quickPromptModal');
    const closeBtn = document.getElementById('quickPromptClose');
    const input = document.getElementById('quickPromptInput');
    const mic = document.getElementById('quickPromptMic');
    const status = document.getElementById('quickPromptStatus');
    const structureBtn = document.getElementById('quickPromptStructure');
    const copyBtn = document.getElementById('quickPromptCopy');
    const copyInlineBtn = document.getElementById('quickPromptCopyInline');
    const clearBtn = document.getElementById('quickPromptClear');
    const header = document.querySelector('.qp-modal-header');

    let recognition = null;
    let isRecording = false;

    function openModal() { modal.classList.add('open'); input?.focus(); }
    function closeModal() { modal.classList.remove('open'); }

    fab?.addEventListener('click', openModal);
    closeBtn?.addEventListener('click', closeModal);

    function clearPrompt() {
      if (!input) return;
      if (isRecording) {
        isRecording = false;
        mic?.classList.remove('recording');
        recognition?.stop();
      }
      input.value = '';
      status.textContent = '';
      input.focus();
    }

    async function copyPrompt() {
      const text = input?.value || '';
      if (!text.trim()) return;
      await navigator.clipboard.writeText(text);
      if (copyInlineBtn) {
        copyInlineBtn.style.color = '#10b981';
        setTimeout(() => { copyInlineBtn.style.color = ''; }, 800);
      }
    }

    clearBtn?.addEventListener('click', clearPrompt);
    copyInlineBtn?.addEventListener('click', copyPrompt);

    // Dragging for root (move anywhere)
    let isDragging = false;
    let startX = 0;
    let startY = 0;
    let startLeft = 0;
    let startTop = 0;

    function setRootPosition(left, top) {
      root.style.left = left + 'px';
      root.style.top = top + 'px';
      root.style.right = 'auto';
      root.style.bottom = 'auto';
      localStorage.setItem('quickPromptPos', JSON.stringify({ left, top }));
    }

    function onDragStart(e) {
      if (!root) return;
      isDragging = true;
      root.classList.add('draggable');
      const rect = root.getBoundingClientRect();
      startLeft = rect.left;
      startTop = rect.top;
      startX = e.clientX;
      startY = e.clientY;
      e.preventDefault();
    }

    function onDragMove(e) {
      if (!isDragging) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      setRootPosition(startLeft + dx, startTop + dy);
    }

    function onDragEnd() {
      isDragging = false;
      root.classList.remove('draggable');
    }

    header?.addEventListener('mousedown', onDragStart);
    fab?.addEventListener('mousedown', onDragStart);
    document.addEventListener('mousemove', onDragMove);
    document.addEventListener('mouseup', onDragEnd);

    // Restore position if saved
    try {
      const saved = JSON.parse(localStorage.getItem('quickPromptPos') || 'null');
      if (saved && typeof saved.left === 'number' && typeof saved.top === 'number') {
        setRootPosition(saved.left, saved.top);
      }
    } catch {}

    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'd') {
        e.preventDefault();
        openModal();
      }
      if (e.key === 'Escape') {
        closeModal();
      }
    });

    // Allow paste into Quick Prompt even without focus
    document.addEventListener('paste', (e) => {
      if (!modal?.classList.contains('open')) return;
      const text = e.clipboardData?.getData('text') || '';
      if (!text) return;
      const isInputFocused = document.activeElement === input;
      if (!isInputFocused) {
        e.preventDefault();
        const current = input.value || '';
        input.value = current + (current ? '\n' : '') + text;
        input.focus();
        input.selectionStart = input.selectionEnd = input.value.length;
      }
    });

    mic?.addEventListener('click', () => {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        status.textContent = 'Din webbläsare stöder inte röstinmatning';
        return;
      }
      if (isRecording) {
        isRecording = false;
        mic.classList.remove('recording');
        recognition?.stop();
        status.textContent = 'Diktering stoppad';
        return;
      }
      recognition = new SpeechRecognition();
      recognition.lang = 'sv-SE';
      recognition.continuous = true;
      recognition.interimResults = true;
      isRecording = true;
      mic.classList.add('recording');
      status.textContent = 'Lyssnar...';
      let finalTranscript = input.value ? input.value + ' ' : '';
      recognition.onresult = (event) => {
        let interim = '';
        for (let i = event.resultIndex; i < event.results.length; i++) {
          if (event.results[i].isFinal) {
            finalTranscript += event.results[i][0].transcript + ' ';
          } else {
            interim += event.results[i][0].transcript;
          }
        }
        input.value = finalTranscript + interim;
      };
      recognition.onerror = (event) => {
        isRecording = false;
        mic.classList.remove('recording');
        status.textContent = 'Fel: ' + event.error;
      };
      recognition.onend = () => {
        if (isRecording) {
          try { recognition.start(); } catch {}
        }
      };
      try { recognition.start(); } catch {}
    });

    const structureHtml = structureBtn?.innerHTML || 'Strukturera prompten';
    structureBtn?.addEventListener('click', async () => {
      const text = input.value.trim();
      if (!text) {
        status.textContent = 'Skriv eller diktera en text först';
        return;
      }
      structureBtn.disabled = true;
      structureBtn.textContent = 'Strukturerar...';
      try {
        const res = await fetch('/api/ai-council/structure-prompt', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ prompt: text })
        });
        const data = await res.json();
        if (!res.ok || data.error) throw new Error(data.error || 'Request failed');
        const structured = data.structuredPrompt || '';
        if (structured) {
          input.value = structured.trim();
          localStorage.setItem('quickPromptLast', structured.trim());
          await navigator.clipboard.writeText(structured.trim());
          status.textContent = 'Strukturerat och kopierat!';
        } else {
          status.textContent = 'Kunde inte strukturera';
        }
      } catch (err) {
        status.textContent = 'Fel: ' + (err?.message || 'okänt fel');
      }
      structureBtn.disabled = false;
      structureBtn.innerHTML = structureHtml;
    });

    copyBtn?.addEventListener('click', async () => {
      const text = input.value.trim();
      if (!text) { status.textContent = 'Ingen text att kopiera'; return; }
      await navigator.clipboard.writeText(text);
      localStorage.setItem('quickPromptLast', text);
      status.textContent = 'Kopierat!';
    });

    // Deliberately omit insert-into-field; user prefers clipboard flow.
  })();
</script>
