---
/**
 * AI Council - Master Mind Tool
 * URL: /admin/ai-council
 * 
 * Features:
 * - Multi-model queries (OpenAI, Anthropic, Google)
 * - Selectable synthesis model
 * - File upload (images, documents)
 * - Supabase session storage with localStorage fallback
 */

export const prerender = false;

import { arInloggad, hamtaAnvandare } from '../../lib/auth';

// Check authentication
if (!await arInloggad(Astro.cookies)) {
  return Astro.redirect('/personal');
}

const anvandare = await hamtaAnvandare(Astro.cookies);
if (!anvandare) {
  return Astro.redirect('/personal');
}
---

<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noindex, nofollow">
  <title>AI Council | Master Mind</title>
  <link rel="icon" type="image/x-icon" href="/favicons/favicon.ico">
  
  <!-- Highlight.js for code syntax -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  
  <!-- Marked.js for Markdown -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  
  <!-- PDF.js for PDF parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  
  <style>
    /* =============================================
       AI COUNCIL - LIGHT THEME (v3.0)
       Inspirerat av Grok/Gemini för professionellt utseende
       ============================================= */
    
    :root {
      /* Bakgrunder */
      --bg-primary: #fafbfc;
      --bg-secondary: #ffffff;
      --bg-sidebar: #f8f9fa;
      --bg-card: #ffffff;
      --bg-input: #f3f4f6;
      --bg-hover: #e5e7eb;
      
      /* Text */
      --text-primary: #111827;
      --text-secondary: #4b5563;
      --text-muted: #6b7280;
      --text-light: #9ca3af;
      
      /* Accent */
      --color-primary: #2563eb;
      --color-primary-hover: #1d4ed8;
      --color-primary-light: rgba(37, 99, 235, 0.1);
      
      /* Borders */
      --border-color: #e5e7eb;
      --border-hover: #d1d5db;
      
      /* Shadows */
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      
      /* Status colors */
      --color-success: #10b981;
      --color-warning: #f59e0b;
      --color-error: #ef4444;
      --color-info: #3b82f6;
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      line-height: 1.6;
    }
    
    .layout { display: flex; min-height: 100vh; }
    .main-area { flex: 1; display: flex; flex-direction: column; min-width: 0; }
    
    /* Project sidebar (left) */
    .project-sidebar {
      width: 280px;
      background: var(--bg-card);
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .project-sidebar-header {
      padding: 1rem;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .project-sidebar-logo {
      font-size: 1.25rem;
      font-weight: 700;
      background: linear-gradient(135deg, #2563eb, #7c3aed, #059669);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .project-sidebar-actions {
      padding: 0.75rem;
      display: flex;
      gap: 0.5rem;
    }
    .project-action-btn {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.375rem;
      padding: 0.5rem;
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: var(--text-secondary);
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.15s;
    }
    .project-action-btn:hover { background: var(--bg-hover); color: var(--text-primary); border-color: var(--color-primary); }
    .project-action-btn.primary { background: var(--color-primary); color: #fff; border-color: var(--color-primary); }
    .project-action-btn.primary:hover { background: var(--color-primary-hover); }
    
    .project-search {
      padding: 0 0.75rem 0.75rem;
    }
    .project-search-input {
      width: 100%;
      padding: 0.5rem 0.75rem 0.5rem 2rem;
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: var(--text-primary);
      font-size: 0.8125rem;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%236b7280'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: 0.5rem center;
      background-size: 1rem;
    }
    .project-search-input:focus { outline: none; border-color: var(--color-primary); }
    .project-search-input::placeholder { color: var(--text-light); }
    
    .project-section {
      padding: 0.5rem 0;
    }
    .project-section-title {
      padding: 0.5rem 1.25rem;
      font-size: 0.6875rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    /* Inline SVG-ikoner */
    .icon-inline {
      vertical-align: -2px;
      margin-right: 4px;
    }
    .icon-inline-sm {
      vertical-align: -2px;
    }
    .project-list {
      flex: 1;
      overflow-y: auto;
      min-height: 0; /* Viktigt för flex overflow */
    }
    .project-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.625rem 1.25rem;
      cursor: pointer;
      transition: all 0.1s;
    }
    .project-item:hover { background: var(--bg-hover); }
    .project-item.active { background: var(--color-primary-light); }
    .project-item-icon { font-size: 1rem; flex-shrink: 0; }
    .project-item-info { flex: 1; min-width: 0; }
    .project-item-name {
      font-size: 0.8125rem;
      font-weight: 500;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .project-item.active .project-item-name { color: var(--color-primary); }
    .project-item-count {
      font-size: 0.6875rem;
      color: var(--text-light);
    }
    .project-item-pin {
      opacity: 0;
      background: transparent;
      border: none;
      color: var(--text-light);
      cursor: pointer;
      padding: 0.25rem;
      font-size: 0.875rem;
    }
    .project-item:hover .project-item-pin { opacity: 1; }
    .project-item-pin.pinned { opacity: 1; color: var(--color-warning); }
    
    /* History accordion in sidebar */
    .history-accordion {
      border-top: 1px solid var(--border-color);
    }
    .history-accordion-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem 1.25rem;
      cursor: pointer;
      background: transparent;
      border: none;
      width: 100%;
      color: var(--text-secondary);
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .history-accordion-header:hover { background: var(--bg-hover); }
    .history-accordion-icon {
      width: 16px;
      height: 16px;
      transition: transform 0.2s;
    }
    .history-accordion.open .history-accordion-icon { transform: rotate(180deg); }
    .history-accordion-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }
    .history-accordion.open .history-accordion-content { max-height: 400px; overflow-y: auto; }
    .history-item {
      display: flex;
      align-items: flex-start;
      gap: 0.75rem;
      padding: 0.5rem 1.25rem;
      cursor: pointer;
      transition: background 0.1s;
    }
    .history-item:hover { background: var(--bg-hover); }
    .history-item-icon { font-size: 0.875rem; color: var(--text-muted); margin-top: 0.125rem; }
    .history-item-info { flex: 1; min-width: 0; }
    .history-item-prompt {
      font-size: 0.75rem;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .history-item-meta {
      font-size: 0.625rem;
      color: var(--text-light);
    }
    
    /* Session accordions (Osorterade, Alla sessioner, Zotero) */
    .session-accordions {
      border-top: 1px solid var(--border-color);
      flex-shrink: 0; /* Förhindra att de krymper */
      background: var(--bg-card); /* Samma bakgrund som sidebar */
    }
    .session-accordion {
      border-bottom: 1px solid var(--border-color);
    }
    .session-accordion:last-child {
      border-bottom: none;
    }
    .session-accordion-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem 1.25rem;
      cursor: pointer;
      background: transparent;
      border: none;
      width: 100%;
      color: var(--text-secondary);
      font-size: 0.8125rem;
      font-weight: 500;
      transition: background 0.1s;
    }
    .session-accordion-header:hover { background: var(--bg-hover); }
    .session-accordion-header-left {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .session-accordion-icon {
      font-size: 1rem;
    }
    .session-accordion-title {
      color: var(--text-primary);
    }
    .session-accordion-count {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 1.5rem;
      height: 1.25rem;
      padding: 0 0.375rem;
      background: var(--bg-hover);
      border-radius: 0.625rem;
      font-size: 0.6875rem;
      font-weight: 600;
      color: var(--text-muted);
    }
    .session-accordion-chevron {
      width: 16px;
      height: 16px;
      color: var(--text-light);
      transition: transform 0.2s;
    }
    .session-accordion.open .session-accordion-chevron { transform: rotate(180deg); }
    .session-accordion-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }
    .session-accordion.open .session-accordion-content { 
      max-height: 200px; /* Begränsat för att ge plats åt alla accordions */
      overflow-y: auto; 
    }
    .session-item {
      display: flex;
      align-items: flex-start;
      gap: 0.75rem;
      padding: 0.5rem 1.25rem 0.5rem 2.5rem;
      cursor: pointer;
      transition: background 0.1s;
    }
    .session-item:hover { background: var(--bg-hover); }
    .session-item-icon { font-size: 0.75rem; color: var(--text-muted); margin-top: 0.125rem; }
    .session-item-info { flex: 1; min-width: 0; }
    .session-item-name {
      font-size: 0.75rem;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .session-item-meta {
      font-size: 0.625rem;
      color: var(--text-light);
    }
    .session-empty {
      padding: 0.75rem 1.25rem 0.75rem 2.5rem;
      font-size: 0.75rem;
      color: var(--text-muted);
      font-style: italic;
    }
    
    /* Zotero Integration */
    .zotero-open-btn { justify-content: space-between; }
    .zotero-status { font-size: 0.625rem; }
    .zotero-status.configured { color: var(--color-success); }
    
    /* Zotero Large Modal */
    .zotero-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
      z-index: 1000;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 2rem;
    }
    .zotero-modal.open { display: flex; }
    
    .zotero-modal-content {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 16px;
      width: 95%;
      max-width: 1200px;
      height: 85vh;
      max-height: 800px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
    }
    
    .zotero-modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border-color);
      background: var(--bg-sidebar);
      border-radius: 16px 16px 0 0;
    }
    .zotero-modal-title {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    .zotero-logo { height: 28px; }
    .zotero-modal-title span { font-size: 0.875rem; color: var(--text-muted); }
    .zotero-modal-close {
      background: transparent;
      border: none;
      font-size: 1.5rem;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0.5rem;
      line-height: 1;
      border-radius: 8px;
    }
    .zotero-modal-close:hover { background: var(--bg-hover); color: var(--text-primary); }
    
    .zotero-modal-body {
      flex: 1;
      display: flex;
      overflow: hidden;
    }
    
    /* Collections sidebar */
    .zotero-modal-sidebar {
      width: 280px;
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      background: var(--bg-sidebar);
    }
    .zotero-collections-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border-color);
      font-weight: 600;
      font-size: 0.875rem;
      color: var(--text-primary);
    }
    .zotero-refresh-btn {
      background: transparent;
      border: none;
      cursor: pointer;
      font-size: 1rem;
      padding: 0.25rem;
      border-radius: 4px;
    }
    .zotero-refresh-btn:hover { background: var(--bg-hover); }
    .zotero-collections-list {
      flex: 1;
      overflow-y: auto;
      padding: 0.5rem;
    }
    .zotero-collection-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.8125rem;
      color: var(--text-primary);
      transition: background 0.1s;
      min-height: 2rem;
    }
    .zotero-collection-item:hover { background: var(--bg-hover); }
    .zotero-collection-item.active { background: var(--accent-color); color: white; }
    .zotero-collection-item.library { font-weight: 600; padding-left: 0.75rem !important; }
    .zotero-collection-icon { font-size: 0.875rem; flex-shrink: 0; }
    .zotero-collection-name { 
      flex: 1; 
      min-width: 0; 
      overflow: hidden; 
      text-overflow: ellipsis; 
      white-space: nowrap;
    }
    .zotero-collection-count {
      margin-left: auto;
      font-size: 0.6875rem;
      background: var(--bg-hover);
      padding: 0.125rem 0.5rem;
      border-radius: 10px;
      color: var(--text-muted);
    }
    .zotero-collection-item.active .zotero-collection-count { background: rgba(255,255,255,0.2); color: white; }
    .zotero-default-collection {
      padding: 0.75rem 1rem;
      border-top: 1px solid var(--border-color);
      font-size: 0.75rem;
      color: var(--text-muted);
    }
    .zotero-default-collection label { display: flex; align-items: center; gap: 0.5rem; cursor: pointer; }
    
    /* Main results area */
    .zotero-modal-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .zotero-search-bar {
      display: flex;
      gap: 0.75rem;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border-color);
    }
    .zotero-modal-search {
      flex: 1;
      padding: 0.75rem 1rem;
      font-size: 0.9375rem;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background: var(--bg-input);
      color: var(--text-primary);
    }
    .zotero-modal-search:focus { outline: none; border-color: var(--accent-color); }
    .zotero-search-btn {
      padding: 0.75rem 1.25rem;
      font-size: 0.875rem;
      font-weight: 500;
      background: var(--accent-color);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
    }
    .zotero-search-btn:hover { opacity: 0.9; }
    
    .zotero-results-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem 1.5rem;
      background: var(--bg-sidebar);
      font-size: 0.8125rem;
      color: var(--text-muted);
    }
    .zotero-select-all label { display: flex; align-items: center; gap: 0.5rem; cursor: pointer; }
    
    .zotero-results-list {
      flex: 1;
      overflow-y: auto;
      padding: 0.5rem;
    }
    
    .zotero-result-item {
      display: flex;
      align-items: flex-start;
      gap: 1rem;
      padding: 1rem 1.25rem;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.15s;
      border: 2px solid transparent;
      margin-bottom: 0.5rem;
    }
    .zotero-result-item:hover { background: var(--bg-hover); }
    .zotero-result-item.selected { 
      background: rgba(59, 130, 246, 0.08); 
      border-color: var(--accent-color); 
    }
    .zotero-result-checkbox {
      width: 20px;
      height: 20px;
      margin-top: 0.125rem;
      cursor: pointer;
    }
    .zotero-result-info { flex: 1; min-width: 0; }
    .zotero-result-title {
      font-size: 0.9375rem;
      font-weight: 500;
      color: var(--text-primary);
      line-height: 1.4;
      margin-bottom: 0.375rem;
    }
    .zotero-result-meta {
      font-size: 0.8125rem;
      color: var(--text-muted);
      margin-bottom: 0.375rem;
    }
    .zotero-result-journal {
      font-size: 0.75rem;
      color: var(--text-light);
      font-style: italic;
    }
    .zotero-result-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 0.375rem;
      margin-top: 0.5rem;
    }
    .zotero-result-tag {
      font-size: 0.6875rem;
      padding: 0.25rem 0.5rem;
      background: var(--bg-hover);
      border-radius: 4px;
      color: var(--text-light);
    }
    .zotero-result-pdf {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      font-size: 0.6875rem;
      padding: 0.25rem 0.5rem;
      background: rgba(34, 197, 94, 0.1);
      color: #22c55e;
      border-radius: 4px;
    }
    
    /* Footer */
    .zotero-modal-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 1.5rem;
      border-top: 1px solid var(--border-color);
      background: var(--bg-sidebar);
      border-radius: 0 0 16px 16px;
    }
    .zotero-footer-left { font-size: 0.875rem; color: var(--text-muted); }
    .zotero-footer-right { display: flex; gap: 0.75rem; }
    
    .zotero-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.625rem 1rem;
      font-size: 0.875rem;
      font-weight: 500;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .zotero-btn-primary { background: var(--accent-color); color: white; }
    .zotero-btn-primary:hover { opacity: 0.9; }
    .zotero-btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
    .zotero-btn-secondary { background: var(--bg-hover); color: var(--text-primary); }
    .zotero-btn-secondary:hover { background: var(--border-color); }
    
    /* Config Modal (liten) */
    .zotero-config-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
      z-index: 1001;
      display: none;
      align-items: center;
      justify-content: center;
    }
    .zotero-config-modal.open { display: flex; }
    .zotero-config-content {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      width: 90%;
      max-width: 400px;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
    }
    .zotero-config-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 1.25rem;
      border-bottom: 1px solid var(--border-color);
    }
    .zotero-config-header h3 { margin: 0; font-size: 1rem; }
    .zotero-config-body { padding: 1.25rem; }
    .zotero-config-body p { margin: 0 0 1rem; font-size: 0.875rem; color: var(--text-muted); }
    .zotero-config-body .zotero-input {
      width: 100%;
      padding: 0.75rem;
      font-size: 0.9375rem;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background: var(--bg-input);
      color: var(--text-primary);
    }
    .zotero-help-text {
      font-size: 0.75rem;
      color: var(--text-light);
      margin-top: 0.75rem;
    }
    .zotero-help-text a { color: var(--accent-color); }
    .zotero-config-footer {
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
      padding: 1rem 1.25rem;
      border-top: 1px solid var(--border-color);
    }
    
    .zotero-loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      color: var(--text-muted);
      font-size: 0.875rem;
    }
    .zotero-empty {
      text-align: center;
      padding: 3rem;
      color: var(--text-muted);
    }
    .zotero-empty-icon { font-size: 3rem; margin-bottom: 1rem; }
    .zotero-error {
      padding: 1rem;
      margin: 1rem;
      background: rgba(239, 68, 68, 0.1);
      border: 1px solid rgba(239, 68, 68, 0.3);
      border-radius: 8px;
      color: #ef4444;
      font-size: 0.875rem;
    }
    
    /* Project context menu */
    .project-context-menu {
      position: fixed;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      box-shadow: var(--shadow-lg);
      min-width: 180px;
      z-index: 1000;
      display: none;
      overflow: hidden;
    }
    .project-context-menu.open { display: block; }
    .context-menu-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.625rem 1rem;
      font-size: 0.8125rem;
      color: var(--text-primary);
      cursor: pointer;
      transition: background 0.1s;
      border: none;
      background: transparent;
      width: 100%;
      text-align: left;
    }
    .context-menu-item:hover { background: var(--bg-hover); }
    .context-menu-item.danger { color: var(--color-error); }
    .context-menu-item.danger:hover { background: rgba(239, 68, 68, 0.1); }
    .context-menu-divider {
      height: 1px;
      background: var(--border-color);
      margin: 0.25rem 0;
    }
    
    /* Color picker for projects */
    .color-picker-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 0.5rem;
      padding: 0.75rem;
    }
    .color-picker-option {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid transparent;
      cursor: pointer;
      transition: transform 0.15s, border-color 0.15s;
    }
    .color-picker-option:hover { transform: scale(1.15); }
    .color-picker-option.selected { border-color: var(--text-primary); }
    
    /* Icon picker */
    .icon-picker-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 0.5rem;
      padding: 0.75rem;
    }
    .icon-picker-option {
      width: 32px;
      height: 32px;
      border-radius: 6px;
      border: 1px solid var(--border-color);
      background: var(--bg-input);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      transition: all 0.15s;
    }
    .icon-picker-option:hover { background: var(--bg-hover); border-color: var(--color-primary); }
    .icon-picker-option.selected { background: var(--color-primary-light); border-color: var(--color-primary); }
    
    @media (max-width: 1200px) {
      .project-sidebar { width: 240px; }
    }
    @media (max-width: 1024px) {
      .project-sidebar { 
        position: fixed; 
        left: 0; 
        top: 0; 
        bottom: 0; 
        z-index: 200; 
        transform: translateX(-100%); 
        box-shadow: var(--shadow-lg);
      }
      .project-sidebar.open { transform: translateX(0); }
    }
    
    /* Notes sidebar */
    .notes-sidebar {
      width: 320px;
      background: var(--bg-sidebar);
      border-left: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
    }
    .notes-sidebar.collapsed { width: 48px; }
    .notes-sidebar.collapsed .notes-content,
    .notes-sidebar.collapsed .notes-header-title,
    .notes-sidebar.collapsed .notes-actions { display: none; }
    
    .notes-header {
      padding: 1rem;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }
    .notes-header-title {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text-secondary);
    }
    .notes-toggle {
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0.25rem;
    }
    .notes-toggle:hover { color: var(--text-primary); }
    
    .notes-content { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
    .notes-list { flex: 1; overflow-y: auto; padding: 0; background: var(--bg-card); }
    
    .note-item {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 0.75rem;
      margin-bottom: 0.5rem;
      font-size: 0.8125rem;
      cursor: pointer;
      box-shadow: var(--shadow-sm);
      transition: all 0.3s ease;
    }
    .note-item:hover { border-color: var(--color-primary); box-shadow: var(--shadow-md); }
    .note-item.new-item {
      animation: highlightNew 2s ease-out;
    }
    @keyframes highlightNew {
      0% { background: rgba(37, 99, 235, 0.2); border-color: var(--color-primary); transform: scale(1.02); }
      100% { background: var(--bg-card); border-color: var(--border-color); transform: scale(1); }
    }
    
    /* Notification badge when sidebar is collapsed */
    .notes-header-title .new-badge {
      background: var(--color-primary);
      color: white;
      font-size: 0.625rem;
      padding: 0.125rem 0.375rem;
      border-radius: 10px;
      margin-left: 0.5rem;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    .note-item-header { 
      display: flex !important; 
      align-items: center !important; 
      justify-content: space-between !important;
      margin-bottom: 0.5rem; 
      flex-wrap: nowrap !important; 
      gap: 0.5rem; 
      position: relative;
    }
    .note-item-time { 
      font-size: 0.75rem; 
      color: var(--text-muted); 
      font-weight: 500; 
      white-space: nowrap; 
      flex-shrink: 0; 
    }
    .note-item-actions { 
      display: inline-flex !important; 
      gap: 0.25rem; 
      flex-shrink: 0; 
      margin-left: auto !important;
    }
    .note-item-btn {
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0.375rem;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }
    .note-item-btn:hover { 
      background: var(--bg-hover);
      transform: scale(1.1);
    }
    .note-item-btn[data-action="view"]:hover { color: var(--color-primary); }
    .note-item-btn[data-action="copy"]:hover { color: var(--color-success); }
    .note-item-btn[data-action="delete"]:hover { color: var(--color-error); }
    .note-item-btn svg {
      width: 16px;
      height: 16px;
      stroke-width: 2;
    }
    /* Hero-style session cards */
    .note-item {
      margin: 0 !important;
      border-radius: 0 !important;
      border-left: none !important;
      border-right: none !important;
      border-top: none !important;
      border-bottom: 1px solid var(--border-color) !important;
      padding: 0.875rem 1rem !important;
    }
    .note-item:last-child { border-bottom: none !important; }
    .note-item.type-supersynthesis { 
      background: linear-gradient(135deg, #FFFBEB 0%, #FEF3C7 100%) !important;
      border-left: 3px solid #F59E0B !important;
    }
    .note-item.type-synthesis { 
      background: linear-gradient(135deg, #EFF6FF 0%, #DBEAFE 100%) !important;
      border-left: 3px solid var(--color-primary) !important;
    }
    .note-item.type-response { 
      background: linear-gradient(135deg, #F9FAFB 0%, #F3F4F6 100%) !important;
      border-left: 3px solid var(--text-light) !important;
    }
    .note-item-name {
      color: var(--text-primary);
      font-weight: 700 !important;
      font-size: 0.9375rem !important;
      margin-bottom: 0.375rem;
      line-height: 1.3;
    }
    .note-item-prompt {
      color: var(--text-secondary);
      font-weight: 400;
      font-size: 0.8125rem;
      margin-bottom: 0.25rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .note-item-arrow { 
      display: inline-flex; 
      align-items: center; 
      color: var(--text-muted); 
      margin-right: 0.25rem;
      vertical-align: middle;
    }
    .note-item-arrow svg { vertical-align: middle; }
    .note-item-type {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-top: 0.375rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 0.375rem;
    }
    .note-item-type-icon { display: flex; align-items: center; }
    .note-item-type-icon svg { vertical-align: middle; }
    .type-supersynthesis .note-item-type-icon { color: #F59E0B; }
    .type-synthesis .note-item-type-icon { color: var(--color-primary); }
    
    .notes-actions {
      padding: 0.75rem;
      border-top: 1px solid var(--border-color);
      display: flex;
      gap: 0.5rem;
    }
    .notes-btn {
      flex: 1;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      padding: 0.5rem;
      border-radius: 6px;
      font-size: 0.75rem;
      cursor: pointer;
    }
    .notes-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
    .notes-btn.danger:hover { background: rgba(239, 68, 68, 0.1); color: var(--color-error); }
    .notes-empty { text-align: center; padding: 2rem 1rem; color: var(--text-light); font-size: 0.8125rem; }
    .notes-sync { font-size: 0.625rem; color: var(--text-muted); padding: 0.5rem 0.75rem; text-align: center; cursor: help; }
    .notes-sync.synced { color: var(--color-success); }
    .notes-sync.error { color: var(--color-error); background: rgba(239, 68, 68, 0.1); border-radius: 4px; }
    .notes-sync.warning { color: var(--color-warning); background: rgba(245, 158, 11, 0.1); border-radius: 4px; }
    
    /* Migration banner for local sessions */
    .migration-banner {
      background: linear-gradient(135deg, #FEF3C7 0%, #FDE68A 100%);
      border: 1px solid #F59E0B;
      border-radius: 8px;
      padding: 12px;
      margin: 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .migration-icon { font-size: 1.5rem; text-align: center; }
    .migration-text { 
      text-align: center;
      color: #92400E;
    }
    .migration-text strong { display: block; font-weight: 600; margin-bottom: 2px; }
    .migration-text span { font-size: 0.75rem; opacity: 0.8; }
    .migration-actions {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin-top: 4px;
    }
    .btn-migrate {
      background: #059669;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 0.75rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s;
    }
    .btn-migrate:hover { background: #047857; }
    .btn-migrate:disabled { opacity: 0.6; cursor: not-allowed; }
    .btn-discard {
      background: transparent;
      color: #DC2626;
      border: 1px solid #DC2626;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 0.75rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }
    .btn-discard:hover { background: #DC2626; color: white; }
    
    /* Session modal */
    .session-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      z-index: 1000;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 2rem;
    }
    .session-modal.open { display: flex; }
    .session-modal-content {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      max-width: 900px;
      width: 100%;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: var(--shadow-lg);
    }
    .session-modal-header {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--bg-sidebar);
    }
    .session-modal-title { font-size: 1rem; font-weight: 600; color: var(--text-primary); }
    .session-modal-meta { font-size: 0.75rem; color: var(--text-muted); }
    .session-modal-close {
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0.25rem;
      line-height: 1;
    }
    .session-modal-close:hover { color: var(--text-primary); }
    .session-modal-body {
      flex: 1;
      overflow-y: auto;
      padding: 1.5rem;
    }
    .session-modal-prompt {
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1.5rem;
    }
    .session-modal-prompt-label { font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; text-transform: uppercase; }
    .session-modal-prompt-text { color: var(--color-primary); font-weight: 500; }
    .session-modal-synthesis { color: var(--text-primary); }
    .session-modal-footer {
      padding: 1rem 1.5rem;
      border-top: 1px solid var(--border-color);
      display: flex;
      gap: 0.75rem;
      background: var(--bg-sidebar);
    }
    .session-modal-btn {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-size: 0.875rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .session-modal-btn:hover { background: var(--bg-hover); }
    .session-modal-btn.primary { background: var(--color-primary); border-color: var(--color-primary); color: #fff; }
    .session-modal-btn.primary:hover { background: var(--color-primary-hover); }
    
    /* Save prompt modal */
    .save-prompt-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(8px);
      z-index: 1100;
      display: none;
      justify-content: center;
      align-items: center;
      padding: 2rem;
    }
    .save-prompt-modal.open { display: flex; }
    .save-prompt-content {
      background: var(--bg-card);
      border: 2px solid var(--color-primary);
      border-radius: 16px;
      max-width: 500px;
      width: 100%;
      box-shadow: 0 0 60px rgba(37, 99, 235, 0.2);
      animation: saveModalPulse 2s ease-in-out infinite;
    }
    @keyframes saveModalPulse {
      0%, 100% { box-shadow: 0 0 40px rgba(37, 99, 235, 0.2); }
      50% { box-shadow: 0 0 60px rgba(37, 99, 235, 0.3); }
    }
    .save-prompt-header {
      padding: 1.5rem;
      text-align: center;
      border-bottom: 1px solid var(--border-color);
    }
    .save-prompt-icon {
      font-size: 3rem;
      margin-bottom: 0.5rem;
      display: block;
    }
    .save-prompt-title {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--color-primary);
      margin-bottom: 0.25rem;
    }
    .save-prompt-subtitle {
      font-size: 0.875rem;
      color: var(--text-secondary);
    }
    .save-prompt-body {
      padding: 1.5rem;
    }
    .save-prompt-input-group {
      margin-bottom: 1rem;
    }
    .save-prompt-label {
      display: block;
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .save-prompt-input {
      width: 100%;
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      padding: 0.75rem 1rem;
      border-radius: 8px;
      font-size: 1rem;
    }
    .save-prompt-input:focus {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: 0 0 0 3px var(--color-primary-light);
    }
    .save-prompt-input::placeholder { color: var(--text-light); }
    .save-prompt-preview {
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 0.75rem 1rem;
      font-size: 0.8125rem;
      color: var(--text-secondary);
      max-height: 60px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .save-prompt-autosave {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem 1rem;
      background: rgba(16, 185, 129, 0.1);
      border: 1px solid rgba(16, 185, 129, 0.3);
      border-radius: 8px;
      margin-top: 1rem;
      cursor: pointer;
    }
    .save-prompt-autosave:hover { background: rgba(16, 185, 129, 0.15); }
    .save-prompt-autosave input { display: none; }
    .save-prompt-autosave-check {
      width: 20px; height: 20px;
      border: 2px solid var(--color-success);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    .save-prompt-autosave-check svg { display: none; width: 14px; height: 14px; color: var(--color-success); }
    .save-prompt-autosave input:checked + .save-prompt-autosave-check svg { display: block; }
    .save-prompt-autosave-text { font-size: 0.8125rem; color: var(--color-success); }
    .save-prompt-footer {
      padding: 1.5rem;
      border-top: 1px solid var(--border-color);
      display: flex;
      gap: 1rem;
    }
    .save-prompt-btn {
      flex: 1;
      padding: 1rem;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      transition: all 0.2s;
    }
    .save-prompt-btn.save {
      background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-hover) 100%);
      border: none;
      color: #fff;
    }
    .save-prompt-btn.save:hover {
      background: linear-gradient(135deg, #3b82f6 0%, var(--color-primary) 100%);
      transform: scale(1.02);
    }
    .save-prompt-btn.skip {
      background: transparent;
      border: 1px solid var(--border-color);
      color: var(--text-muted);
    }
    .save-prompt-btn.skip:hover { background: var(--bg-hover); color: var(--text-primary); }
    
    /* Header */
    .header {
      background: var(--bg-card);
      border-bottom: 1px solid var(--border-color);
      padding: 1rem 1.5rem;
      /* Removed sticky positioning - user preference */
      z-index: 100;
      box-shadow: var(--shadow-sm);
    }
    .header-inner { max-width: 1200px; margin: 0 auto; display: flex; align-items: center; justify-content: space-between; }
    .header-left { display: flex; align-items: center; gap: 1rem; }
    .mobile-menu-btn {
      display: none;
      background: transparent;
      border: none;
      color: var(--text-muted);
      padding: 0.5rem;
      cursor: pointer;
    }
    .mobile-menu-btn:hover { color: var(--text-primary); }
    @media (max-width: 1024px) {
      .mobile-menu-btn { display: flex; }
    }
    .back-link { color: var(--text-muted); text-decoration: none; font-size: 0.875rem; }
    .back-link:hover { color: var(--color-primary); }
    .logo h1 {
      font-size: 1.25rem;
      font-weight: 700;
      background: linear-gradient(135deg, #2563eb, #7c3aed, #059669);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .logo span { font-size: 0.75rem; color: var(--text-muted); }
    .header-right { display: flex; align-items: center; gap: 1rem; }
    .profile-link {
      display: flex;
      align-items: center;
      gap: 0.375rem;
      padding: 0.375rem 0.75rem;
      background: var(--color-primary-light);
      border: 1px solid rgba(37, 99, 235, 0.3);
      border-radius: 6px;
      color: var(--color-primary);
      font-size: 0.8125rem;
      text-decoration: none;
      transition: all 0.15s;
    }
    .profile-link:hover {
      background: rgba(37, 99, 235, 0.15);
      border-color: rgba(37, 99, 235, 0.5);
      color: var(--color-primary-hover);
    }
    .user-email { font-size: 0.875rem; color: var(--text-muted); }
    .model-dots { display: flex; gap: 4px; }
    .model-dot { width: 8px; height: 8px; border-radius: 50%; }
    
    /* Price-based colors: green (cheap) → red (expensive) */
    .dot-google { background: #22c55e; }     /* Gemini - cheapest (~$0.10/1M) */
    .dot-anthropic { background: #eab308; }  /* Claude - medium (~$3/1M) */
    .dot-grok { background: #f97316; }       /* Grok - medium-high (~$5/1M) */
    .dot-openai { background: #ef4444; }     /* OpenAI o1 - most expensive (~$15/1M) */
    
    /* Single model run section */
    .single-model-section {
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.05), rgba(16, 185, 129, 0.05));
      border: 1px dashed var(--border-color);
      border-radius: 10px;
      padding: 0.875rem;
      margin-bottom: 1rem;
    }
    .sequential-controls {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 0.625rem;
    }
    .run-sequential-btn {
      display: flex;
      align-items: center;
      gap: 0.375rem;
      padding: 0.5rem 1rem;
      background: linear-gradient(135deg, #3b82f6, #10b981);
      border: none;
      border-radius: 6px;
      font-size: 0.8125rem;
      font-weight: 600;
      color: white;
      cursor: pointer;
      transition: all 0.15s;
    }
    .run-sequential-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }
    .run-sequential-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    .run-sequential-btn.running {
      background: linear-gradient(135deg, #f59e0b, #ef4444);
      animation: pulse 1.5s ease-in-out infinite;
    }
    .sound-toggle {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      font-size: 0.75rem;
      color: var(--text-muted);
      cursor: pointer;
    }
    .sound-toggle input {
      width: 14px;
      height: 14px;
    }
    .single-model-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.625rem;
    }
    .single-model-title {
      font-size: 0.8125rem;
      font-weight: 600;
      color: var(--text-secondary);
    }
    .single-model-hint {
      font-size: 0.6875rem;
      color: var(--text-muted);
    }
    .single-model-buttons {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .single-model-btn {
      display: flex;
      align-items: center;
      gap: 0.375rem;
      padding: 0.5rem 0.75rem;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.15s;
    }
    .single-model-btn:hover {
      border-color: var(--color-primary);
      background: var(--color-primary-light);
      color: var(--color-primary);
    }
    .single-model-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .single-model-btn.running {
      background: var(--color-primary);
      color: white;
      border-color: var(--color-primary);
    }
    .single-model-btn.done {
      border-color: #22c55e;
      color: #22c55e;
      background: rgba(34, 197, 94, 0.1);
    }
    .single-model-btn .dot-google,
    .single-model-btn .dot-anthropic,
    .single-model-btn .dot-grok,
    .single-model-btn .dot-openai {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    
    /* Single deliberation buttons - same style as single-model-btn */
    .single-deliberation-btn {
      display: flex;
      align-items: center;
      gap: 0.375rem;
      padding: 0.5rem 0.75rem;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.15s;
    }
    .single-deliberation-btn:hover {
      border-color: #f59e0b;
      background: rgba(245, 158, 11, 0.1);
      color: #f59e0b;
    }
    .single-deliberation-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .single-deliberation-btn.running {
      background: #f59e0b;
      color: white;
      border-color: #f59e0b;
    }
    .single-deliberation-btn.done {
      border-color: #22c55e;
      color: #22c55e;
    }
    .single-deliberation-btn .dot-google,
    .single-deliberation-btn .dot-anthropic,
    .single-deliberation-btn .dot-grok,
    .single-deliberation-btn .dot-openai {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    
    /* Price legend */
    .price-legend {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
      font-size: 0.75rem;
      color: var(--text-muted);
    }
    .price-legend-label { font-weight: 500; }
    .price-legend-item { display: flex; align-items: center; gap: 0.25rem; }
    .price-legend-arrow { color: var(--text-light); }
    .price-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }
    .price-cheap { background: linear-gradient(135deg, #22c55e, #84cc16); }
    .price-expensive { background: linear-gradient(135deg, #f97316, #ef4444); }
    
    /* Model selection checkboxes */
    .model-selection {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-bottom: 1.5rem;
    }
    .model-checkbox {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.75rem;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .model-checkbox:hover { border-color: var(--color-primary); background: var(--bg-hover); }
    .model-checkbox.selected { border-color: var(--color-primary); background: var(--color-primary-light); }
    
    /* Profile selector */
    .profile-selector {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-bottom: 1rem;
    }
    .profile-btn {
      position: relative;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.875rem;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 0.8125rem;
      cursor: pointer;
      transition: all 0.15s;
    }
    .profile-btn:hover { border-color: var(--color-primary); background: var(--bg-hover); color: var(--text-primary); }
    .profile-btn.active { border-color: var(--color-primary); background: var(--color-primary-light); color: var(--color-primary); }
    .profile-btn.turbo.active { border-color: #10b981; background: rgba(16, 185, 129, 0.1); color: #10b981; }
    .profile-btn .profile-icon { font-size: 1rem; }
    .profile-btn .profile-name { font-weight: 500; }
    .profile-btn .profile-desc { font-size: 0.6875rem; color: var(--text-muted); }
    .profile-btn.active .profile-desc { color: inherit; opacity: 0.7; }
    
    /* Profile tooltips */
    .profile-tooltip {
      position: absolute;
      bottom: calc(100% + 10px);
      left: 50%;
      transform: translateX(-50%);
      width: 280px;
      padding: 1rem;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      box-shadow: var(--shadow-lg);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s, visibility 0.2s;
      z-index: 100;
      pointer-events: none;
    }
    .profile-btn:hover .profile-tooltip {
      opacity: 1;
      visibility: visible;
    }
    .profile-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 8px solid transparent;
      border-top-color: var(--border-color);
    }
    .profile-tooltip-title {
      font-size: 0.9375rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .profile-tooltip-why {
      font-size: 0.8125rem;
      color: var(--text-secondary);
      margin-bottom: 0.75rem;
      line-height: 1.5;
    }
    .profile-tooltip-config {
      font-size: 0.75rem;
      color: var(--text-muted);
      padding-top: 0.75rem;
      border-top: 1px solid var(--border-color);
    }
    .profile-tooltip-config div {
      margin-bottom: 0.25rem;
    }
    .profile-tooltip-config strong {
      color: var(--text-secondary);
    }
    .profile-tooltip-tag {
      display: inline-block;
      padding: 0.125rem 0.375rem;
      background: var(--color-primary-light);
      color: var(--color-primary);
      border-radius: 4px;
      font-size: 0.6875rem;
      margin-left: 0.25rem;
    }
    .profile-tooltip-tag.turbo {
      background: rgba(16, 185, 129, 0.15);
      color: #10b981;
    }
    .model-checkbox.unavailable { opacity: 0.4; cursor: not-allowed; }
    .model-checkbox input { display: none; }
    .model-checkbox-dot { width: 10px; height: 10px; border-radius: 50%; }
    .model-checkbox-name { font-size: 0.8125rem; color: var(--text-primary); }
    .model-checkbox-desc { font-size: 0.6875rem; color: var(--text-muted); }
    .model-checkbox.selected .model-checkbox-name { color: var(--color-primary); font-weight: 600; }
    .model-checkbox-check {
      width: 16px; height: 16px;
      border: 2px solid var(--border-color);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      color: transparent;
    }
    .model-checkbox.selected .model-checkbox-check {
      background: var(--color-primary);
      border-color: var(--color-primary);
      color: #fff;
    }
    
    /* Deliberation toggle */
    .deliberation-toggle {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.5rem 0.75rem;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      cursor: pointer;
    }
    .deliberation-toggle:hover { border-color: var(--color-primary); background: var(--bg-hover); }
    .deliberation-toggle.active { border-color: #f59e0b; background: rgba(245, 158, 11, 0.1); }
    .deliberation-toggle input { display: none; }
    .deliberation-toggle-switch {
      width: 36px; height: 20px;
      background: var(--border-color);
      border-radius: 10px;
      position: relative;
      transition: background 0.2s;
    }
    .deliberation-toggle-switch::after {
      content: '';
      position: absolute;
      width: 16px; height: 16px;
      background: var(--text-light);
      border-radius: 50%;
      top: 2px; left: 2px;
      transition: all 0.2s;
    }
    .deliberation-toggle.active .deliberation-toggle-switch { background: #f59e0b; }
    .deliberation-toggle.active .deliberation-toggle-switch::after { background: #fff; left: 18px; }
    .deliberation-toggle-label { font-size: 0.8125rem; color: var(--text-secondary); }
    .deliberation-toggle.active .deliberation-toggle-label { color: #f59e0b; }
    .deliberation-toggle-desc { font-size: 0.6875rem; color: var(--text-muted); }
    .deliberation-toggle.active .deliberation-toggle-desc { color: #b45309; }
    
    /* Workflow progress indicator */
    .workflow-progress {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 1rem 1.5rem;
      margin-bottom: 1.5rem;
      box-shadow: var(--shadow-sm);
    }
    .workflow-steps {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .workflow-step {
      display: flex;
      align-items: center;
      gap: 0.375rem;
      padding: 0.5rem 0.75rem;
      background: var(--bg-input);
      border-radius: 20px;
      font-size: 0.8125rem;
      color: var(--text-muted);
      transition: all 0.2s;
    }
    .workflow-step.active {
      background: var(--color-primary-light);
      color: var(--color-primary);
      font-weight: 500;
    }
    .workflow-step.completed {
      background: rgba(16, 185, 129, 0.1);
      color: #059669;
    }
    .workflow-step-arrow { color: var(--text-light); font-size: 0.875rem; }
    .workflow-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid var(--border-color);
      font-size: 0.75rem;
      color: var(--text-muted);
    }
    .reset-workflow-btn {
      background: transparent;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 0.375rem 0.75rem;
      font-size: 0.75rem;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.15s;
    }
    .reset-workflow-btn:hover { border-color: #ef4444; color: #ef4444; background: rgba(239, 68, 68, 0.05); }
    
    /* Round 2 section */
    .round-label {
      font-size: 0.75rem;
      font-weight: 600;
      color: #f59e0b;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin: 1.5rem 0 0.75rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--border-color);
    }
    .round-label.round-1 { color: var(--color-primary); }
    
    /* Main content */
    .main { max-width: 1200px; margin: 0 auto; padding: 2rem 1.5rem; width: 100%; }
    
    /* Input card */
    .input-card {
      background: linear-gradient(135deg, #2563eb, #7c3aed, #059669);
      padding: 2px;
      border-radius: 16px;
      margin-bottom: 2rem;
    }
    .input-card-inner { background: var(--bg-card); border-radius: 14px; padding: 1.5rem; }
    .form-group { margin-bottom: 1.5rem; }
    .form-label { display: block; font-size: 0.875rem; font-weight: 500; color: var(--text-primary); margin-bottom: 0.5rem; }
    .form-label .icon { margin-right: 0.5rem; }
    .form-label .optional { color: var(--text-muted); font-weight: 400; }
    .form-label .required { color: var(--color-error); }
    
    textarea, input[type="text"], select {
      width: 100%;
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      border-radius: 8px;
      padding: 0.875rem 1rem;
      font-size: 0.9375rem;
      font-family: inherit;
    }
    textarea { resize: vertical; }
    textarea:focus, input:focus, select:focus {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: 0 0 0 3px var(--color-primary-light);
    }
    textarea::placeholder, input::placeholder { color: var(--text-light); }
    .context-input { min-height: 120px; font-family: 'Monaco', 'Menlo', monospace; font-size: 0.875rem; }
    .prompt-input { min-height: 80px; padding-right: 60px; }
    
    /* Prompt wrapper with dictation button */
    .prompt-wrapper {
      position: relative;
    }
    .dictation-btn {
      position: absolute;
      right: 8px;
      bottom: 8px;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: var(--bg-input);
      border: 2px solid var(--border-color);
      color: var(--text-muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      z-index: 10;
    }
    .dictation-btn:hover {
      background: var(--color-primary-light);
      border-color: var(--color-primary);
      color: var(--color-primary);
    }
    .dictation-btn.recording {
      background: #fef2f2;
      border-color: #ef4444;
      color: #ef4444;
      animation: pulse-ring 1.5s ease-out infinite;
    }
    .dictation-btn.recording .dictation-pulse {
      display: block;
    }
    .dictation-icon {
      width: 20px;
      height: 20px;
    }
    .dictation-pulse {
      display: none;
      position: absolute;
      inset: -4px;
      border-radius: 50%;
      border: 2px solid #ef4444;
      animation: pulse-expand 1.5s ease-out infinite;
    }
    @keyframes pulse-ring {
      0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); }
      70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
      100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
    }
    @keyframes pulse-expand {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(1.4); opacity: 0; }
    }
    .dictation-status {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-top: 0.5rem;
      min-height: 1.25rem;
    }
    .dictation-status.recording {
      color: #ef4444;
      font-weight: 500;
    }
    .dictation-status.error {
      color: var(--color-error);
    }
    .dictation-status.success {
      color: var(--color-success);
    }
    
    /* Mobile dictation improvements */
    @media (max-width: 768px) {
      .dictation-btn {
        width: 52px;
        height: 52px;
        right: 6px;
        bottom: 6px;
      }
      .dictation-icon {
        width: 24px;
        height: 24px;
      }
      .prompt-input {
        min-height: 100px;
        padding-right: 70px;
        font-size: 16px; /* Förhindrar zoom på iOS */
      }
    }
    
    /* File upload */
    .file-upload-row {
      display: flex;
      gap: 0.75rem;
      margin-top: 0.75rem;
      align-items: stretch;
    }
    .file-upload-area {
      flex: 1;
      border: 2px dashed var(--border-color);
      border-radius: 8px;
      padding: 1rem;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.2s, background 0.2s;
    }
    .file-upload-area:hover { border-color: var(--color-primary); background: var(--bg-hover); }
    .file-upload-area.dragover { border-color: var(--color-primary); background: var(--color-primary-light); }
    .file-upload-icon { font-size: 1.5rem; margin-bottom: 0.5rem; }
    .file-upload-text { font-size: 0.8125rem; color: var(--text-muted); }
    .file-upload-text strong { color: var(--color-primary); }
    
    /* Camera button */
    .camera-btn {
      display: none; /* Hidden on desktop by default */
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 1rem;
      background: linear-gradient(135deg, #8b5cf6, #6366f1);
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      min-width: 80px;
      transition: all 0.2s;
    }
    .camera-btn:hover {
      transform: scale(1.02);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
    }
    .camera-btn:active {
      transform: scale(0.98);
    }
    .camera-icon {
      width: 28px;
      height: 28px;
    }
    .camera-label {
      font-size: 0.75rem;
      font-weight: 600;
    }
    
    /* Show camera button on mobile/tablet */
    @media (max-width: 1024px) {
      .camera-btn {
        display: flex;
      }
    }
    
    /* On very small screens, stack vertically */
    @media (max-width: 480px) {
      .file-upload-row {
        flex-direction: column;
      }
      .camera-btn {
        flex-direction: row;
        min-width: 100%;
        padding: 1rem 1.5rem;
      }
      .camera-icon {
        width: 24px;
        height: 24px;
      }
    }
    .file-list { 
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 0.75rem; 
    }
    .file-item {
      position: relative;
      display: inline-block;
    }
    .file-item.has-thumbnail .file-item-name,
    .file-item.has-thumbnail .file-item-size {
      display: none;
    }
    .file-item:not(.has-thumbnail) {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.75rem;
      background: var(--bg-input);
      border-radius: 8px;
      font-size: 0.8125rem;
    }
    .file-item-name { flex: 1; color: var(--text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 200px; }
    .file-item-size { color: var(--text-muted); font-size: 0.75rem; }
    .file-item-remove {
      position: absolute;
      top: -8px;
      right: -8px;
      width: 22px;
      height: 22px;
      background: rgba(0, 0, 0, 0.75);
      border: 2px solid white;
      border-radius: 50%;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: bold;
      transition: background 0.15s, transform 0.15s;
      z-index: 5;
    }
    .file-item-remove:hover { 
      background: #ef4444;
      transform: scale(1.1);
    }
    .file-item:not(.has-thumbnail) .file-item-remove {
      position: static;
      width: auto;
      height: auto;
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 14px;
    }
    .file-item:not(.has-thumbnail) .file-item-remove:hover {
      color: #ef4444;
      transform: none;
    }
    .file-item-icon { font-size: 1rem; flex-shrink: 0; }
    .file-list .file-item .file-item-thumbnail,
    .file-item-thumbnail { 
      width: 96px !important; 
      height: 96px !important; 
      max-width: 96px !important;
      max-height: 96px !important;
      object-fit: cover; 
      border-radius: 8px; 
      border: 2px solid var(--border-color);
      display: block;
      transition: border-color 0.15s;
    }
    .file-item:hover .file-item-thumbnail {
      border-color: var(--color-primary);
    }
    .file-list .file-item img,
    .file-item img {
      width: 96px !important;
      height: 96px !important;
      max-width: 96px !important;
      max-height: 96px !important;
      object-fit: cover !important;
    }
    
    @media (max-width: 768px) {
      .file-item-thumbnail {
        width: 80px;
        height: 80px;
      }
      .file-item img {
        max-width: 80px !important;
        max-height: 80px !important;
      }
    }
    
    /* Paste indicator */
    .paste-hint {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      font-size: 0.6875rem;
      color: var(--text-muted);
      margin-left: 0.5rem;
    }
    .paste-hint kbd {
      background: var(--bg-hover);
      padding: 0.125rem 0.375rem;
      border-radius: 3px;
      font-family: inherit;
      font-size: 0.625rem;
    }
    
    /* Synthesis model selector */
    .synthesis-selector {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    .synthesis-selector label { font-size: 0.8125rem; color: var(--text-secondary); }
    .synthesis-selector select {
      width: auto;
      padding: 0.5rem 2rem 0.5rem 0.75rem;
      font-size: 0.8125rem;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%236b7280'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 9l-7 7-7-7'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 0.5rem center;
      background-size: 1rem;
      appearance: none;
    }
    
    /* Actions row */
    .actions-row { display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 1rem; }
    .model-legend { display: flex; align-items: center; gap: 1rem; font-size: 0.75rem; color: var(--text-muted); }
    .model-legend-item { display: flex; align-items: center; gap: 0.375rem; }
    .model-legend-dot { width: 8px; height: 8px; border-radius: 50%; }
    
    .run-btn {
      background: linear-gradient(135deg, #2563eb, #7c3aed, #059669);
      color: white;
      border: none;
      padding: 0.875rem 2rem;
      font-size: 1rem;
      font-weight: 600;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .run-btn:hover:not(:disabled) { opacity: 0.9; }
    .run-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .run-btn .spinner {
      width: 18px; height: 18px;
      border: 2px solid transparent;
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      display: none; /* Hidden by default, shown when .loading class is added */
    }
    
    /* Retry button */
    .retry-btn {
      padding: 0.75rem 1.25rem;
      font-size: 0.875rem;
      font-weight: 500;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: all 0.2s;
      background: #fef3c7;
      color: #92400e;
      border: 1px solid #f59e0b;
    }
    .retry-btn:hover { background: #fde68a; }
    .expand-btn {
      padding: 0.75rem 1.25rem;
      font-size: 0.875rem;
      font-weight: 500;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: all 0.2s;
      background: linear-gradient(135deg, #3b82f6, #60a5fa);
      color: white;
      border: none;
    }
    .expand-btn:hover { opacity: 0.9; }
    .retry-btn:disabled, .expand-btn:disabled { 
      opacity: 0.5; 
      cursor: not-allowed; 
    }
    
    /* Next step cards */
    .next-step-cards {
      margin-top: 1.5rem;
      padding: 1.25rem;
      background: var(--bg-sidebar);
      border-radius: 12px;
      border: 1px solid var(--border-color);
    }
    .next-step-header {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .next-step-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
    }
    @media (max-width: 640px) {
      .next-step-grid { grid-template-columns: 1fr; }
    }
    .next-step-card {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.5rem;
      padding: 1.25rem;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
      border: 2px solid transparent;
      text-align: left;
      background: none;
    }
    .next-step-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0,0,0,0.12);
    }
    .next-step-card:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    .deliberate-card {
      background: linear-gradient(135deg, rgba(124, 58, 237, 0.08), rgba(139, 92, 246, 0.12));
      border-color: rgba(124, 58, 237, 0.25);
    }
    .deliberate-card:hover:not(:disabled) {
      background: linear-gradient(135deg, rgba(124, 58, 237, 0.15), rgba(139, 92, 246, 0.2));
      border-color: #7c3aed;
    }
    .synthesize-card {
      background: linear-gradient(135deg, rgba(5, 150, 105, 0.08), rgba(16, 185, 129, 0.12));
      border-color: rgba(5, 150, 105, 0.25);
    }
    .synthesize-card:hover:not(:disabled) {
      background: linear-gradient(135deg, rgba(5, 150, 105, 0.15), rgba(16, 185, 129, 0.2));
      border-color: #059669;
    }
    .add-models-card {
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.08), rgba(96, 165, 250, 0.12));
      border-color: rgba(59, 130, 246, 0.25);
    }
    .add-models-card:hover:not(:disabled) {
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(96, 165, 250, 0.2));
      border-color: #3b82f6;
    }
    .add-models-card .next-step-card-title { color: #3b82f6; }
    .add-models-card .model-dots {
      display: flex;
      gap: 0.25rem;
      margin-top: 0.25rem;
    }
    .add-models-card .model-dot-unused {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      opacity: 0.7;
    }
    .next-step-card-icon {
      font-size: 1.75rem;
    }
    .next-step-card-title {
      font-size: 1.125rem;
      font-weight: 700;
    }
    .deliberate-card .next-step-card-title { color: #7c3aed; }
    .synthesize-card .next-step-card-title { color: #059669; }
    .next-step-card-desc {
      font-size: 0.8125rem;
      color: var(--text-secondary);
      line-height: 1.4;
    }
    .next-step-card-meta {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-top: 0.5rem;
      width: 100%;
    }
    .next-step-card-count {
      font-size: 0.75rem;
      font-weight: 600;
      padding: 0.25rem 0.625rem;
      border-radius: 12px;
    }
    .deliberate-card .next-step-card-count {
      background: rgba(124, 58, 237, 0.15);
      color: #7c3aed;
    }
    .synthesize-card .next-step-card-count {
      background: rgba(5, 150, 105, 0.15);
      color: #059669;
    }
    .next-step-card-time {
      font-size: 0.6875rem;
      color: var(--text-muted);
    }
    .next-step-card.done {
      opacity: 0.6;
      pointer-events: none;
    }
    .next-step-card.done .next-step-card-count {
      background: rgba(34, 197, 94, 0.2);
      color: #16a34a;
    }
    /* Highlight pulse animation for buttons */
    @keyframes highlight-pulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0.7); }
      50% { box-shadow: 0 0 0 10px rgba(37, 99, 235, 0); }
    }
    .highlight-pulse {
      animation: highlight-pulse 1s ease-in-out 2;
    }
    .run-btn.loading .spinner { display: block; }
    .run-btn.loading .btn-text { display: none; }
    @keyframes spin { to { transform: rotate(360deg); } }
    
    /* Status & Error */
    .status {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 1rem 1.25rem;
      margin-bottom: 1.5rem;
      display: none;
      align-items: center;
      gap: 0.75rem;
      box-shadow: var(--shadow-sm);
    }
    .status.visible { display: flex; }
    .status-dot {
      width: 10px; height: 10px;
      border-radius: 50%;
      background: var(--color-primary);
      animation: pulse 1.5s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .status-text { font-size: 0.875rem; color: var(--text-secondary); }
    
    .error {
      background: rgba(239, 68, 68, 0.1);
      border: 1px solid rgba(239, 68, 68, 0.3);
      border-radius: 8px;
      padding: 1rem 1.25rem;
      margin-bottom: 1.5rem;
      color: var(--color-error);
      font-size: 0.875rem;
      display: none;
    }
    .error.visible { display: block; }
    
    /* Logout banner - prominent warning when session expired */
    .logout-banner {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #f59e0b, #d97706);
      color: white;
      padding: 0.875rem 1.5rem;
      display: none;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      z-index: 9999;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      font-size: 0.9375rem;
    }
    .logout-banner.visible { display: flex; }
    .logout-banner-icon { font-size: 1.25rem; }
    .logout-banner-text { font-weight: 500; }
    .logout-banner-btn {
      background: white;
      color: #d97706;
      border: none;
      padding: 0.5rem 1.25rem;
      border-radius: 6px;
      font-size: 0.875rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
    }
    .logout-banner-btn:hover { 
      background: #fef3c7; 
      transform: translateY(-1px);
    }
    .logout-banner-dismiss {
      background: transparent;
      border: none;
      color: white;
      opacity: 0.8;
      cursor: pointer;
      padding: 0.25rem;
      font-size: 1.25rem;
      line-height: 1;
    }
    .logout-banner-dismiss:hover { opacity: 1; }
    /* Adjust layout when banner is visible */
    body.has-logout-banner .layout { margin-top: 52px; }
    
    /* Results */
    .results { display: none; }
    .results.visible { display: block; }
    
    /* Copy button */
    .copy-btn {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      padding: 0.375rem 0.75rem;
      border-radius: 6px;
      font-size: 0.75rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.375rem;
    }
    .copy-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
    .copy-btn.copied { background: rgba(16, 185, 129, 0.1); color: var(--color-success); }
    .copy-btn svg { width: 14px; height: 14px; }
    
    .export-md-btn {
      background: var(--color-primary-light);
      border: 1px solid var(--color-primary);
      color: var(--color-primary);
      padding: 0.375rem 0.75rem;
      border-radius: 6px;
      font-size: 0.75rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.375rem;
    }
    .export-md-btn:hover { background: var(--color-primary); color: #fff; }
    .export-md-btn svg { width: 14px; height: 14px; }
    
    /* Synthesis card */
    .synthesis-card {
      background: rgba(37, 99, 235, 0.05);
      border: 1px solid rgba(37, 99, 235, 0.2);
      border-left: 4px solid var(--color-primary);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 2rem;
    }
    .synthesis-header { display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1rem; flex-wrap: wrap; }
    .synthesis-icon { font-size: 1.5rem; }
    .synthesis-title { flex: 1; }
    .synthesis-title h2 { font-size: 1.125rem; font-weight: 600; color: var(--color-primary); margin-bottom: 0.25rem; }
    .synthesis-meta { 
      display: flex; 
      align-items: center; 
      gap: 0.5rem; 
      flex-wrap: wrap;
      font-size: 0.75rem; 
      color: var(--text-muted); 
    }
    .synthesis-meta-divider { color: var(--border-color); }
    .synthesis-models-used {
      display: flex;
      align-items: center;
      gap: 0.375rem;
    }
    .synthesis-model-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      display: inline-block;
    }
    .synthesis-model-dot.google { background: #10b981; }
    .synthesis-model-dot.anthropic { background: #f59e0b; }
    .synthesis-model-dot.grok { background: #3b82f6; }
    .synthesis-model-dot.openai { background: #6b7280; }
    .synthesis-profile {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.125rem 0.5rem;
      background: var(--bg-input);
      border-radius: 4px;
      font-size: 0.6875rem;
      font-weight: 500;
    }
    .synthesis-actions { display: flex; align-items: center; gap: 0.5rem; }
    .synthesis-duration { font-size: 0.75rem; color: var(--text-muted); }
    .synthesis-content { color: var(--text-primary); }
    
    .save-note-btn {
      background: transparent;
      border: 1px solid rgba(37, 99, 235, 0.3);
      color: var(--color-primary);
      padding: 0.375rem 0.75rem;
      border-radius: 6px;
      font-size: 0.75rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.375rem;
    }
    .save-note-btn:hover { background: var(--color-primary-light); }
    .save-note-btn.saved { background: rgba(16, 185, 129, 0.1); color: var(--color-success); }
    
    /* Chat bubble layout */
    .chat-container {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }
    .chat-message {
      display: flex;
      gap: 0.75rem;
      max-width: 85%;
    }
    .chat-message.user {
      align-self: flex-end;
      flex-direction: row-reverse;
    }
    .chat-message.ai {
      align-self: flex-start;
    }
    .chat-avatar {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      flex-shrink: 0;
    }
    .chat-message.user .chat-avatar {
      background: var(--color-primary);
      color: #fff;
    }
    .chat-message.ai .chat-avatar {
      background: linear-gradient(135deg, #2563eb, #7c3aed, #059669);
      color: #fff;
    }
    .chat-bubble {
      padding: 0.875rem 1rem;
      border-radius: 12px;
      font-size: 0.9375rem;
      line-height: 1.6;
    }
    .chat-message.user .chat-bubble {
      background: var(--color-primary);
      color: #fff;
      border-bottom-right-radius: 4px;
    }
    .chat-message.ai .chat-bubble {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      border-bottom-left-radius: 4px;
      box-shadow: var(--shadow-sm);
    }
    .chat-bubble-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      font-size: 0.75rem;
      font-weight: 600;
    }
    .chat-message.user .chat-bubble-header { color: rgba(255,255,255,0.8); }
    .chat-message.ai .chat-bubble-header { color: var(--text-muted); }
    .chat-bubble-actions {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid var(--border-color);
    }
    .chat-message.user .chat-bubble-actions { border-color: rgba(255,255,255,0.2); }
    
    /* Accordion */
    .responses-section h3 {
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 1rem;
    }
    .responses-grid { display: flex; flex-direction: column; gap: 0.75rem; }
    
    .accordion { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden; box-shadow: var(--shadow-sm); }
    /* Price-based accordion colors matching model dots */
    .accordion.google { border-left: 3px solid #22c55e; }    /* Gemini - cheapest */
    .accordion.anthropic { border-left: 3px solid #eab308; } /* Claude - medium */
    .accordion.grok { border-left: 3px solid #f97316; }      /* Grok - medium-high */
    .accordion.openai { border-left: 3px solid #ef4444; }    /* OpenAI o1 - expensive */
    
    .accordion-header {
      width: 100%;
      background: transparent;
      border: none;
      padding: 1rem 1.25rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
    }
    .accordion-header:hover { background: var(--bg-hover); }
    .accordion-header-left { display: flex; align-items: center; gap: 0.75rem; }
    .accordion-dot { width: 10px; height: 10px; border-radius: 50%; }
    .accordion-title { font-size: 0.9375rem; font-weight: 500; color: var(--text-primary); }
    .accordion-status { font-size: 0.75rem; color: var(--text-muted); margin-left: 0.5rem; }
    .accordion-status.success { color: var(--color-success); }
    .accordion-status.error { color: var(--color-error); }
    .accordion-status.waiting { color: var(--color-primary); }
    .accordion-status.waiting::before { 
      content: ''; 
      display: inline-block; 
      width: 10px; 
      height: 10px; 
      border: 2px solid var(--color-primary); 
      border-top-color: transparent; 
      border-radius: 50%; 
      animation: spin 1s linear infinite; 
      margin-right: 4px; 
      vertical-align: middle;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .accordion-header-right { display: flex; align-items: center; gap: 0.75rem; }
    .accordion-duration { font-size: 0.75rem; color: var(--text-muted); }
    .accordion-icon { width: 20px; height: 20px; color: var(--text-muted); transition: transform 0.2s; }
    .accordion.open .accordion-icon { transform: rotate(180deg); }
    
    .accordion-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; }
    .accordion.open .accordion-content { max-height: 3000px; }
    .accordion-content-inner { padding: 0 1.25rem 1.25rem; border-top: 1px solid var(--border-color); }
    .accordion-content-inner .markdown-content { padding-top: 1rem; }
    .accordion-content-actions { display: flex; gap: 0.5rem; padding-top: 1rem; border-top: 1px solid var(--border-color); margin-top: 1rem; }
    
    .total-stats { display: flex; justify-content: center; gap: 2rem; flex-wrap: wrap; padding-top: 1.5rem; border-top: 1px solid var(--border-color); margin-top: 1.5rem; font-size: 0.875rem; color: var(--text-muted); }
    .total-duration { }
    .total-cost { color: var(--color-success); }
    .total-cost .cost-details { display: block; font-size: 0.75rem; color: var(--text-muted); margin-top: 0.25rem; }
    
    /* Cost banner at top */
    .cost-banner {
      display: none;
      background: rgba(16, 185, 129, 0.05);
      border: 1px solid rgba(16, 185, 129, 0.2);
      border-radius: 12px;
      padding: 1rem 1.5rem;
      margin-bottom: 1.5rem;
    }
    .cost-banner.visible { display: block; }
    .cost-banner-main {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 1rem;
    }
    .cost-banner-left {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    .cost-banner-icon { font-size: 1.5rem; }
    .cost-banner-amount {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--color-success);
    }
    .cost-banner-sek {
      font-size: 0.875rem;
      color: #059669;
      margin-left: 0.5rem;
    }
    .cost-banner-right {
      display: flex;
      gap: 1.5rem;
      font-size: 0.8125rem;
      color: var(--text-muted);
    }
    .cost-banner-stat {
      display: flex;
      align-items: center;
      gap: 0.375rem;
    }
    .cost-banner-stat-value { color: var(--text-secondary); font-weight: 500; }
    
    /* Hallucination Report */
    .hallucination-report {
      background: rgba(59, 130, 246, 0.05);
      border: 1px solid rgba(59, 130, 246, 0.2);
      border-radius: 12px;
      padding: 1.25rem 1.5rem;
      margin-bottom: 1.5rem;
    }
    .hallucination-report.has-issues {
      background: rgba(251, 191, 36, 0.05);
      border-color: rgba(251, 191, 36, 0.2);
    }
    .hallucination-report.has-high {
      background: rgba(239, 68, 68, 0.05);
      border-color: rgba(239, 68, 68, 0.2);
    }
    .hallucination-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1rem;
    }
    .hallucination-icon { font-size: 1.5rem; }
    .hallucination-title h2 { font-size: 1rem; font-weight: 600; color: var(--color-info); margin: 0; }
    .hallucination-title span { font-size: 0.75rem; color: var(--text-muted); }
    .hallucination-summary {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 1rem;
    }
    .hallucination-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      font-size: 0.875rem;
      font-weight: 500;
    }
    .hallucination-status-good {
      background: rgba(16, 185, 129, 0.1);
      color: var(--color-success);
    }
    .hallucination-status-warning {
      background: rgba(245, 158, 11, 0.1);
      color: var(--color-warning);
    }
    .hallucination-status-danger {
      background: rgba(239, 68, 68, 0.1);
      color: var(--color-error);
    }
    .hallucination-counts {
      display: flex;
      gap: 1rem;
    }
    .hallucination-count {
      display: flex;
      align-items: center;
      gap: 0.375rem;
      font-size: 0.8125rem;
    }
    .hallucination-count .count-num { font-weight: 600; color: var(--text-primary); }
    .hallucination-count .count-label { color: var(--text-muted); }
    .hallucination-details { margin-top: 1rem; }
    .hallucination-toggle {
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 0.5rem 1rem;
      color: var(--text-secondary);
      font-size: 0.8125rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .hallucination-toggle:hover { background: var(--bg-hover); color: var(--text-primary); }
    .hallucination-list { margin-top: 1rem; }
    .hallucination-item {
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 0.75rem;
    }
    .hallucination-item.high { border-left: 3px solid var(--color-error); }
    .hallucination-item.medium { border-left: 3px solid var(--color-warning); }
    .hallucination-item.low { border-left: 3px solid #eab308; }
    .hallucination-item-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }
    .hallucination-item-claim {
      font-style: italic;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
      padding-left: 0.5rem;
      border-left: 2px solid var(--border-color);
    }
    .hallucination-item-meta {
      font-size: 0.75rem;
      color: var(--text-muted);
    }
    .hallucination-item-meta span { margin-right: 1rem; }
    
    /* Markdown */
    .markdown-content { line-height: 1.7; color: var(--text-primary); }
    .markdown-content h1, .markdown-content h2, .markdown-content h3, .markdown-content h4 { color: var(--text-primary); margin-top: 1.5em; margin-bottom: 0.5em; }
    .markdown-content h1:first-child, .markdown-content h2:first-child, .markdown-content h3:first-child { margin-top: 0; }
    .markdown-content h1 { font-size: 1.5em; font-weight: 700; }
    .markdown-content h2 { font-size: 1.25em; font-weight: 600; }
    .markdown-content h3 { font-size: 1.1em; font-weight: 600; }
    .markdown-content p { margin-bottom: 1em; }
    .markdown-content ul, .markdown-content ol { margin-left: 1.5em; margin-bottom: 1em; }
    .markdown-content li { margin-bottom: 0.25em; }
    .markdown-content code { background: #f3f4f6; color: #374151; padding: 0.2em 0.4em; border-radius: 4px; font-size: 0.875em; font-family: 'Monaco', 'Menlo', monospace; }
    .markdown-content pre { background: #1e293b; color: #e2e8f0; padding: 1rem; border-radius: 8px; overflow-x: auto; margin-bottom: 1em; }
    .markdown-content pre code { background: transparent; color: #e2e8f0; padding: 0; font-size: 0.875rem; }
    .markdown-content blockquote { border-left: 3px solid var(--color-primary); padding-left: 1em; margin-left: 0; margin-bottom: 1em; color: var(--text-secondary); }
    .markdown-content table { width: 100%; border-collapse: collapse; margin-bottom: 1em; }
    .markdown-content th, .markdown-content td { border: 1px solid var(--border-color); padding: 0.5em 0.75em; text-align: left; }
    .markdown-content th { background: var(--bg-input); font-weight: 600; }
    .markdown-content a { color: var(--color-primary); text-decoration: none; }
    .markdown-content a:hover { text-decoration: underline; }
    .markdown-content strong { color: var(--text-primary); font-weight: 600; }
    
    @media (max-width: 768px) {
      .notes-sidebar { position: fixed; right: 0; top: 0; bottom: 0; z-index: 200; transform: translateX(100%); }
      .notes-sidebar.open { transform: translateX(0); }
    }
    @media (max-width: 768px) {
      .header-inner { flex-direction: column; gap: 1rem; align-items: flex-start; }
      .actions-row { flex-direction: column; align-items: stretch; }
      .run-btn { justify-content: center; min-height: 48px; font-size: 1rem; }
      .notes-sidebar { width: 100%; }
      
      /* Larger touch targets for all interactive elements */
      .model-checkbox {
        min-height: 48px;
        padding: 0.75rem 1rem;
      }
      .notes-btn {
        min-height: 44px;
        font-size: 0.875rem;
      }
      .note-item-btn {
        min-width: 40px;
        min-height: 40px;
        padding: 0.5rem;
      }
      .note-item-btn svg {
        width: 20px;
        height: 20px;
        justify-content: center;
      }
      .session-modal-btn {
        min-height: 44px;
        font-size: 0.875rem;
      }
      
      /* Better mobile spacing */
      .main { padding: 1rem; }
      .form-group { margin-bottom: 1.25rem; }
      .form-label { font-size: 0.9375rem; margin-bottom: 0.75rem; }
      
      /* Synthesis actions mobile */
      .synthesis-actions {
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      .synthesis-actions button {
        min-height: 40px;
        padding: 0.5rem 0.75rem;
      }
      
      /* Profile selector mobile - horizontal scroll */
      .profile-selector {
        display: flex;
        gap: 0.5rem;
        overflow-x: auto;
        padding-bottom: 0.5rem;
        margin: 0 -1rem;
        padding-left: 1rem;
        padding-right: 1rem;
        scrollbar-width: none;
        -ms-overflow-style: none;
      }
      .profile-selector::-webkit-scrollbar { display: none; }
      .profile-btn {
        flex-shrink: 0;
        min-height: 56px;
        padding: 0.625rem 1rem;
      }
      .profile-btn .profile-icon { font-size: 1.25rem; }
      .profile-btn .profile-name { font-size: 0.875rem; }
      
      /* Hide tooltips on mobile */
      .profile-tooltip { display: none !important; }
      
      /* Context input mobile */
      .context-input {
        font-size: 14px; /* Prevent zoom on iOS */
        min-height: 100px;
      }
    }
    
    /* Mobile FAB for notes sidebar */
    .mobile-notes-fab {
      display: none;
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: var(--color-primary);
      color: white;
      border: none;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4), 0 2px 4px rgba(0, 0, 0, 0.1);
      z-index: 150;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }
    .mobile-notes-fab:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 16px rgba(37, 99, 235, 0.5), 0 4px 8px rgba(0, 0, 0, 0.15);
    }
    .mobile-notes-fab:active {
      transform: scale(0.95);
    }
    .mobile-notes-fab-badge {
      position: absolute;
      top: -4px;
      right: -4px;
      min-width: 20px;
      height: 20px;
      padding: 0 6px;
      background: #ef4444;
      color: white;
      font-size: 0.6875rem;
      font-weight: 700;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .mobile-notes-fab-badge:empty,
    .mobile-notes-fab-badge[data-count="0"] {
      display: none;
    }
    @media (max-width: 1024px) {
      .mobile-notes-fab { display: flex; }
    }
    
    /* Mobile overlay for sidebars */
    .mobile-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 190;
      opacity: 0;
      transition: opacity 0.2s;
    }
    .mobile-overlay.active {
      display: block;
      opacity: 1;
    }
  </style>
</head>
<body>
  <!-- Logout banner - shown when session expires -->
  <div id="logoutBanner" class="logout-banner">
    <span class="logout-banner-icon">⚠️</span>
    <span class="logout-banner-text">Din session har gått ut. Logga in igen för att fortsätta.</span>
    <button class="logout-banner-btn" onclick="window.location.href='/personal'">Logga in</button>
    <button class="logout-banner-dismiss" onclick="dismissLogoutBanner()" title="Stäng">×</button>
  </div>
  
  <div class="layout">
    <!-- Project Sidebar (Left) -->
    <aside class="project-sidebar" id="projectSidebar">
      <div class="project-sidebar-header">
        <span class="project-sidebar-logo">AI Council</span>
      </div>
      
      <div class="project-sidebar-actions">
        <button class="project-action-btn primary" id="newChatBtn" title="Starta ny chat">
          ✨ Ny chat
        </button>
        <button class="project-action-btn" id="newProjectBtn" title="Skapa nytt projekt">
          📁 +
        </button>
        <a href="/admin/kunskapsbas" class="project-action-btn" title="Kunskapsbas" style="text-decoration: none;">
          📚 KB
        </a>
      </div>
      
      <div class="project-search">
        <input type="text" class="project-search-input" placeholder="Sök i sessioner..." id="projectSearch">
      </div>
      
      <div class="project-section">
        <div class="project-section-title"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon-inline"><line x1="12" y1="17" x2="12" y2="22"></line><path d="M5 17h14v-1.76a2 2 0 0 0-1.11-1.79l-1.78-.89A2 2 0 0 1 15 10.76V6h1a2 2 0 0 0 0-4H8a2 2 0 0 0 0 4h1v4.76a2 2 0 0 1-1.11 1.79l-1.78.89A2 2 0 0 0 5 15.24z"></path></svg>Senaste projekt</div>
      </div>
      
      <div class="project-list" id="projectList">
        <!-- Projekten laddas dynamiskt -->
      </div>
      
      <!-- Session accordions -->
      <div class="session-accordions">
        <!-- Zotero Integration - Öppnar stor modal -->
        <div class="session-accordion" id="zoteroAccordion">
          <button class="session-accordion-header zotero-open-btn" id="zoteroOpenBtn">
            <span class="session-accordion-header-left">
              <span class="session-accordion-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg></span>
              <span class="session-accordion-title">Zotero</span>
            </span>
            <span class="session-accordion-count zotero-status" id="zoteroStatus">—</span>
            <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
            </svg>
          </button>
        </div>
        
        <!-- Osorterade sessioner -->
        <div class="session-accordion" id="unsortedAccordion">
          <button class="session-accordion-header">
            <span class="session-accordion-header-left">
              <span class="session-accordion-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg></span>
              <span class="session-accordion-title">Osorterade</span>
            </span>
            <span class="session-accordion-count" id="unsortedCount">0</span>
            <svg class="session-accordion-chevron" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
            </svg>
          </button>
          <div class="session-accordion-content" id="unsortedList">
            <!-- Osorterade sessioner laddas dynamiskt -->
          </div>
        </div>
        
        <!-- Alla sessioner -->
        <div class="session-accordion" id="allSessionsAccordion">
          <button class="session-accordion-header">
            <span class="session-accordion-header-left">
              <span class="session-accordion-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg></span>
              <span class="session-accordion-title">Alla sessioner</span>
            </span>
            <span class="session-accordion-count" id="allSessionsCount">0</span>
            <svg class="session-accordion-chevron" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
            </svg>
          </button>
          <div class="session-accordion-content" id="allSessionsList">
            <!-- Alla sessioner laddas dynamiskt -->
          </div>
        </div>
      </div>
    </aside>
    
    <!-- Zotero Modal (stor) -->
    <div class="zotero-modal" id="zoteroModal">
      <div class="zotero-modal-content">
        <div class="zotero-modal-header">
          <div class="zotero-modal-title">
            <img src="https://www.zotero.org/static/images/promote/zotero-logo-512x123.svg" alt="Zotero" class="zotero-logo">
            <span id="zoteroModalUser"></span>
          </div>
          <button class="zotero-modal-close" id="zoteroModalClose">✕</button>
        </div>
        
        <div class="zotero-modal-body">
          <!-- Vänster: Collections -->
          <div class="zotero-modal-sidebar">
            <div class="zotero-collections-header">
              <span>📁 Collections</span>
              <button class="zotero-refresh-btn" id="zoteroRefreshCollections" title="Uppdatera"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg></button>
            </div>
            <div class="zotero-collections-list" id="zoteroCollectionsList">
              <div class="zotero-loading">Laddar...</div>
            </div>
            <div class="zotero-default-collection">
              <label>
                <input type="checkbox" id="zoteroSetDefault">
                <span>Sätt som standard</span>
              </label>
            </div>
          </div>
          
          <!-- Höger: Sök och resultat -->
          <div class="zotero-modal-main">
            <div class="zotero-search-bar">
              <input type="text" class="zotero-modal-search" id="zoteroModalSearch" placeholder="Sök i biblioteket...">
              <button class="zotero-search-btn" id="zoteroModalSearchBtn">🔍 Sök</button>
            </div>
            
            <div class="zotero-results-header" id="zoteroResultsHeader">
              <span id="zoteroResultsCount">Välj en collection eller sök</span>
              <div class="zotero-select-all">
                <label>
                  <input type="checkbox" id="zoteroSelectAll">
                  <span>Välj alla</span>
                </label>
              </div>
            </div>
            
            <div class="zotero-results-list" id="zoteroModalResults">
              <!-- Resultat laddas här -->
            </div>
          </div>
        </div>
        
        <div class="zotero-modal-footer">
          <div class="zotero-footer-left">
            <span id="zoteroSelectedInfo">0 valda</span>
          </div>
          <div class="zotero-footer-right">
            <button class="zotero-btn zotero-btn-secondary" id="zoteroDisconnectBtn">🔌 Koppla från</button>
            <button class="zotero-btn zotero-btn-primary" id="zoteroImportSelectedBtn" disabled>📥 Importera valda PDF:er</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Zotero Config Modal (liten) -->
    <div class="zotero-config-modal" id="zoteroConfigModal">
      <div class="zotero-config-content">
        <div class="zotero-config-header">
          <h3>🔑 Konfigurera Zotero</h3>
          <button class="zotero-modal-close" id="zoteroConfigClose">✕</button>
        </div>
        <div class="zotero-config-body">
          <p>Klistra in din Zotero API-nyckel för att komma igång.</p>
          <input type="text" class="zotero-input" id="zoteroApiKeyInput" placeholder="API-nyckel (24 tecken)" autocomplete="off">
          <div class="zotero-help-text">
            Hämta din nyckel från <a href="https://www.zotero.org/settings/keys" target="_blank">zotero.org/settings/keys</a>
          </div>
        </div>
        <div class="zotero-config-footer">
          <button class="zotero-btn zotero-btn-secondary" id="zoteroConfigCancel">Avbryt</button>
          <button class="zotero-btn zotero-btn-primary" id="zoteroConfigSave">🔑 Spara</button>
        </div>
      </div>
    </div>
    
    <div class="main-area">
      <header class="header">
        <div class="header-inner">
          <div class="header-left">
            <button class="mobile-menu-btn" id="mobileMenuBtn" title="Visa projekt">
              <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
              </svg>
            </button>
            <a href="/personal/oversikt" class="back-link">← Tillbaka</a>
            <div class="logo">
              <h1>AI Council</h1>
              <span>Master Mind Tool</span>
            </div>
          </div>
          <div class="header-right">
            <a href="/admin/ai-council/profil" class="profile-link" title="Redigera din AI-profil">
              👤 Min profil
            </a>
            <span class="user-email">{anvandare.email}</span>
            <div class="model-dots" title="Prissorterad: billigast → dyrast">
              <span class="model-dot dot-google" title="Gemini 2.0 Flash (~$0.10/1M)"></span>
              <span class="model-dot dot-anthropic" title="Claude Sonnet (~$3/1M)"></span>
              <span class="model-dot dot-grok" title="Grok 4 (~$5/1M)"></span>
              <span class="model-dot dot-openai" title="OpenAI o1 (~$15/1M)"></span>
            </div>
          </div>
        </div>
      </header>

      <main class="main">
        <section class="input-card">
          <div class="input-card-inner">
            <!-- Context -->
            <div class="form-group">
              <label class="form-label">
                <span class="icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line></svg></span> Kontext
                <span class="optional">(valfritt - kod, dokumentation)</span>
              </label>
              <textarea id="context" class="context-input" placeholder="Klistra in kod, dokumentation eller bakgrundsinfo..."></textarea>
              
              <!-- File upload with camera -->
              <div class="file-upload-row">
                <div id="fileUploadArea" class="file-upload-area">
                  <div class="file-upload-icon">📎</div>
                  <div class="file-upload-text">
                    <strong>Klicka</strong>, dra filer, eller <strong>Ctrl+V</strong> för att klistra in bilder<br>
                    <span style="font-size: 0.75rem;">PNG, JPG, PDF, TXT, MD, JSON • Bilder skickas till multimodala AI:er</span>
                  </div>
                  <input type="file" id="fileInput" multiple accept=".png,.jpg,.jpeg,.gif,.webp,.pdf,.txt,.md,.json,.js,.ts,.py,.html,.css" style="display:none">
                </div>
                <button type="button" class="camera-btn" id="cameraBtn" title="Ta foto med kamera">
                  <svg class="camera-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                    <circle cx="12" cy="13" r="4"></circle>
                  </svg>
                  <span class="camera-label">Kamera</span>
                </button>
                <input type="file" id="cameraInput" accept="image/*" capture="environment" style="display:none">
              </div>
              <div id="fileList" class="file-list"></div>
            </div>
            
            <!-- Prompt -->
            <div class="form-group">
              <label class="form-label">
                <span class="icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg></span> Prompt <span class="required">*</span>
              </label>
              <div class="prompt-wrapper">
                <textarea id="prompt" class="prompt-input" placeholder="Ställ din fråga eller tryck på mikrofonen för att diktera..." required></textarea>
                <button type="button" class="dictation-btn" id="dictationBtn" title="Diktera (tryck för att starta/stoppa)">
                  <svg class="dictation-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                    <line x1="12" y1="19" x2="12" y2="23"></line>
                    <line x1="8" y1="23" x2="16" y2="23"></line>
                  </svg>
                  <span class="dictation-pulse"></span>
                </button>
              </div>
              <div class="dictation-status" id="dictationStatus"></div>
            </div>
            
            <!-- Profile selector -->
            <div class="form-group">
              <label class="form-label">
                <span class="icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg></span> Välj profil
              </label>
              <div class="profile-selector" id="profileSelector">
                <button type="button" class="profile-btn turbo active" data-profile="snabb">
                  <span class="profile-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg></span>
                  <div>
                    <div class="profile-name">Snabb</div>
                    <div class="profile-desc">~3-5 sek</div>
                  </div>
                  <div class="profile-tooltip">
                    <div class="profile-tooltip-title"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon-inline-sm"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg> Snabb <span class="profile-tooltip-tag turbo">STANDARD</span></div>
                    <div class="profile-tooltip-why">
                      Blixtsnabbt svar med Gemini. Perfekt för enkla frågor och när du inte vill vänta.
                      Undviker Netlify timeout-problem.
                    </div>
                    <div class="profile-tooltip-config">
                      <div><strong>Modell:</strong> Gemini 2.0 Flash</div>
                      <div><strong>Syntes:</strong> Gemini (direkt)</div>
                      <div><strong>Tid:</strong> ~2-5 sek</div>
                    </div>
                  </div>
                </button>
                <button type="button" class="profile-btn turbo" data-profile="patient">
                  <span class="profile-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 12h-4l-3 9L9 3l-3 9H2"></path></svg></span>
                  <div>
                    <div class="profile-name">Patientfrågor</div>
                    <div class="profile-desc">Turbo + kontroll</div>
                  </div>
                  <div class="profile-tooltip">
                    <div class="profile-tooltip-title"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon-inline-sm"><path d="M22 12h-4l-3 9L9 3l-3 9H2"></path></svg> Patientfrågor <span class="profile-tooltip-tag turbo">TURBO</span></div>
                    <div class="profile-tooltip-why">
                      Optimerad för telefonsamtal med patienter. Blixtsnabb respons när du 
                      behöver svara direkt. Två modeller kontrollerar varandra för säkerhet.
                    </div>
                    <div class="profile-tooltip-config">
                      <div><strong>Modeller:</strong> Gemini 2.0 Flash + Claude Sonnet</div>
                      <div><strong>Syntes:</strong> GPT-4o (snabbast)</div>
                      <div><strong>Deliberation:</strong> Av (för snabbhet)</div>
                    </div>
                  </div>
                </button>
                <button type="button" class="profile-btn" data-profile="kod">
                  <span class="profile-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg></span>
                  <div>
                    <div class="profile-name">Kodning</div>
                    <div class="profile-desc">Alla + Deliberation</div>
                  </div>
                  <div class="profile-tooltip">
                    <div class="profile-tooltip-title"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon-inline-sm"><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg> Kodning (Premium)</div>
                    <div class="profile-tooltip-why">
                      Maximal kodgranskning med alla 4 modeller + deliberation.
                      Perfekt för arkitekturbeslut, säkerhet, prestanda och läsbarhet.
                    </div>
                    <div class="profile-tooltip-config">
                      <div><strong>Modeller:</strong> o1 + Claude + Gemini + Grok</div>
                      <div><strong>Syntes:</strong> Claude Opus 4.5</div>
                      <div><strong>Deliberation:</strong> ✓ Aktiverad</div>
                      <div><strong>Tid:</strong> ~30-60 sek</div>
                    </div>
                  </div>
                </button>
                <button type="button" class="profile-btn" data-profile="vetenskap">
                  <span class="profile-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 2v7.527a2 2 0 0 1-.211.896L4.72 20.55a1 1 0 0 0 .9 1.45h12.76a1 1 0 0 0 .9-1.45l-5.069-10.127A2 2 0 0 1 14 9.527V2"></path><path d="M8.5 2h7"></path><path d="M7 16h10"></path></svg></span>
                  <div>
                    <div class="profile-name">Vetenskap</div>
                    <div class="profile-desc">3 modeller + o1</div>
                  </div>
                  <div class="profile-tooltip">
                    <div class="profile-tooltip-title"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon-inline-sm"><path d="M10 2v7.527a2 2 0 0 1-.211.896L4.72 20.55a1 1 0 0 0 .9 1.45h12.76a1 1 0 0 0 .9-1.45l-5.069-10.127A2 2 0 0 1 14 9.527V2"></path><path d="M8.5 2h7"></path><path d="M7 16h10"></path></svg> Vetenskap</div>
                    <div class="profile-tooltip-why">
                      Gemini (stort kontext), Claude (analys), Grok (referenser).
                      OpenAI o1 granskar och syntetiserar med djup resonering.
                    </div>
                    <div class="profile-tooltip-config">
                      <div><strong>Modeller:</strong> Gemini + Claude + Grok</div>
                      <div><strong>Syntes:</strong> OpenAI o1 (resonering)</div>
                      <div><strong>Tid:</strong> ~20-40 sek</div>
                    </div>
                  </div>
                </button>
                <button type="button" class="profile-btn" data-profile="strategi">
                  <span class="profile-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line></svg></span>
                  <div>
                    <div class="profile-name">Strategi</div>
                    <div class="profile-desc">o1 + Claude + Grok</div>
                  </div>
                  <div class="profile-tooltip">
                    <div class="profile-tooltip-title"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon-inline-sm"><line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line></svg> Strategi & Beslut</div>
                    <div class="profile-tooltip-why">
                      För verksamhetsbeslut, investeringar och organisationsfrågor.
                      o1 resonerar, Claude strukturerar, Grok ger bred kontext.
                    </div>
                    <div class="profile-tooltip-config">
                      <div><strong>Modeller:</strong> o1 + Claude + Grok</div>
                      <div><strong>Syntes:</strong> Claude Opus 4.5</div>
                      <div><strong>Tid:</strong> ~20-40 sek</div>
                    </div>
                  </div>
                </button>
              </div>
            </div>
            
            <!-- Model selection -->
            <div class="form-group">
              <label class="form-label">
                <span class="icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect><rect x="9" y="9" width="6" height="6"></rect><line x1="9" y1="1" x2="9" y2="4"></line><line x1="15" y1="1" x2="15" y2="4"></line><line x1="9" y1="20" x2="9" y2="23"></line><line x1="15" y1="20" x2="15" y2="23"></line><line x1="20" y1="9" x2="23" y2="9"></line><line x1="20" y1="14" x2="23" y2="14"></line><line x1="1" y1="9" x2="4" y2="9"></line><line x1="1" y1="14" x2="4" y2="14"></line></svg></span> Välj AI-modeller
                <span class="optional">(eller använd profil)</span>
              </label>
              
              <!-- Price legend -->
              <div class="price-legend">
                <span class="price-legend-label">Pris:</span>
                <span class="price-legend-item"><span class="price-dot price-cheap"></span>Billig</span>
                <span class="price-legend-arrow">→</span>
                <span class="price-legend-item"><span class="price-dot price-expensive"></span>Dyr</span>
              </div>
              
              <!-- Single model run buttons -->
              <div class="single-model-section">
                <div class="single-model-header">
                  <span class="single-model-title">🔬 Kör modeller sekventiellt</span>
                  <span class="single-model-hint">(stabilt, en åt gången)</span>
                </div>
                <div class="sequential-controls">
                  <button type="button" id="runAllSequentialBtn" class="run-sequential-btn" title="Kör alla valda modeller i sekvens">
                    ▶️ Kör alla i sekvens
                  </button>
                  <label class="sound-toggle" title="Spela ljud när modell är klar">
                    <input type="checkbox" id="soundNotification" checked>
                    <span>🔔 Ljud</span>
                  </label>
                </div>
                <div class="single-model-buttons">
                  <button type="button" class="single-model-btn" data-model="gemini" title="Kör endast Gemini">
                    <span class="dot-google"></span> Gemini
                  </button>
                  <button type="button" class="single-model-btn" data-model="anthropic" title="Kör endast Claude">
                    <span class="dot-anthropic"></span> Claude
                  </button>
                  <button type="button" class="single-model-btn" data-model="grok" title="Kör endast Grok">
                    <span class="dot-grok"></span> Grok
                  </button>
                  <button type="button" class="single-model-btn" data-model="openai" title="Kör endast OpenAI">
                    <span class="dot-openai"></span> OpenAI
                  </button>
                </div>
              </div>
              
              <!-- Models ordered by price: cheapest → most expensive (left → right) -->
              <div class="model-selection" id="modelSelection">
                <label class="model-checkbox selected" data-model="gemini">
                  <input type="checkbox" checked>
                  <span class="model-checkbox-check">✓</span>
                  <span class="model-checkbox-dot dot-google"></span>
                  <div>
                    <div class="model-checkbox-name">Gemini 2.0 Flash</div>
                    <div class="model-checkbox-desc">Snabbast · ~$0.10/1M</div>
                  </div>
                </label>
                <label class="model-checkbox selected" data-model="anthropic">
                  <input type="checkbox" checked>
                  <span class="model-checkbox-check">✓</span>
                  <span class="model-checkbox-dot dot-anthropic"></span>
                  <div>
                    <div class="model-checkbox-name">Claude Sonnet</div>
                    <div class="model-checkbox-desc">Struktur & kod · ~$3/1M</div>
                  </div>
                </label>
                <label class="model-checkbox" data-model="grok">
                  <input type="checkbox">
                  <span class="model-checkbox-check">✓</span>
                  <span class="model-checkbox-dot dot-grok"></span>
                  <div>
                    <div class="model-checkbox-name">Grok 4</div>
                    <div class="model-checkbox-desc">Referenser · ~$5/1M</div>
                  </div>
                </label>
                <label class="model-checkbox" data-model="openai">
                  <input type="checkbox">
                  <span class="model-checkbox-check">✓</span>
                  <span class="model-checkbox-dot dot-openai"></span>
                  <div>
                    <div class="model-checkbox-name">OpenAI o1</div>
                    <div class="model-checkbox-desc">Djup logik · ~$15/1M</div>
                  </div>
                </label>
              </div>
            </div>
            
            <!-- Actions -->
            <div class="actions-row">
              <div style="display: flex; align-items: center; gap: 1.5rem; flex-wrap: wrap;">
                <div class="synthesis-selector">
                  <label for="synthesisModel">Syntes-modell:</label>
                  <select id="synthesisModel">
                    <!-- Ordered by price: cheapest → most expensive -->
                    <option value="gemini">🟢 Gemini (billigast ~$0.10/1M)</option>
                    <option value="gpt4o">🟡 GPT-4o (snabb ~$2.50/1M)</option>
                    <option value="claude">🟡 Claude Sonnet (kod ~$3/1M)</option>
                    <option value="grok">🟠 Grok (vetenskap ~$5/1M)</option>
                    <option value="openai">🔴 OpenAI o1 (logik ~$15/1M)</option>
                    <option value="claude-opus">🔴 Claude Opus 4.5 (bäst ~$15/1M)</option>
                  </select>
                </div>
                <label id="deliberationToggle" class="deliberation-toggle">
                  <input type="checkbox" id="enableDeliberation">
                  <span class="deliberation-toggle-switch"></span>
                  <div>
                    <div class="deliberation-toggle-label">Deliberation</div>
                    <div class="deliberation-toggle-desc">Runda 2: Modeller granskar varandra</div>
                  </div>
                </label>
                <label id="skipSynthesisToggle" class="deliberation-toggle skip-synthesis-toggle" title="För debugging - kör endast modellerna utan syntes">
                  <input type="checkbox" id="skipSynthesis">
                  <span class="deliberation-toggle-switch"></span>
                  <div>
                    <div class="deliberation-toggle-label">🔧 Testa</div>
                    <div class="deliberation-toggle-desc">Hoppa över syntes (debug)</div>
                  </div>
                </label>
              </div>
              <button type="button" id="runBtn" class="run-btn">
                <span class="btn-text"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="icon-inline"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg>Kör AI Council</span>
                <span class="spinner"></span>
              </button>
              <button type="button" id="retryFailedBtn" class="retry-btn" style="display: none;" title="Kör endast modeller som misslyckades">
                <span><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon-inline"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>Försök igen (misslyckade)</span>
              </button>
              <button type="button" id="expandModelsBtn" class="expand-btn" style="display: none;" title="Lägg till fler modeller till befintliga svar">
                <span>➕ Lägg till modeller</span>
              </button>
            </div>
            
            <!-- Next step cards -->
            <div id="nextStepCards" class="next-step-cards" style="display: none;">
              <div class="next-step-header">Välj nästa steg</div>
              <div class="next-step-grid">
                <button type="button" id="addModelsCardBtn" class="next-step-card add-models-card" style="display: none;">
                  <div class="next-step-card-icon">➕</div>
                  <div class="next-step-card-title">Lägg till modeller</div>
                  <div class="next-step-card-desc">Kör fler AI:er med samma fråga utan att köra om de som redan svarat</div>
                  <div class="next-step-card-meta">
                    <span class="next-step-card-count" id="addModelsCount">0 kvar</span>
                    <div class="model-dots" id="unusedModelDots"></div>
                  </div>
                </button>
                <button type="button" id="deliberateNowBtn" class="next-step-card deliberate-card">
                  <div class="next-step-card-icon">🔬</div>
                  <div class="next-step-card-title">Faktagranskning</div>
                  <div class="next-step-card-desc">Alla AI:er granskar varandras svar och korrigerar fel</div>
                  <div class="next-step-card-meta">
                    <span class="next-step-card-count" id="deliberateCount">0 svar</span>
                    <span class="next-step-card-time">⏱️ ~60 sek</span>
                  </div>
                </button>
                <button type="button" id="synthesizeNowBtn" class="next-step-card synthesize-card">
                  <div class="next-step-card-icon">🧪</div>
                  <div class="next-step-card-title">Sammanfattning</div>
                  <div class="next-step-card-desc">En AI sammanfattar alla svar till en slutsats</div>
                  <div class="next-step-card-meta">
                    <span class="next-step-card-count" id="synthesizeCount">0 svar</span>
                    <span class="next-step-card-time">⏱️ ~15 sek</span>
                  </div>
                </button>
              </div>
            </div>
            
            <!-- Single-model deliberation buttons -->
            <div id="singleDeliberationSection" class="single-model-section" style="display: none;">
              <div class="single-model-header">
                <span class="single-model-title">🔬 Kör deliberation en modell i taget</span>
                <span class="single-model-hint">(stabilt, en åt gången)</span>
              </div>
              <div class="single-model-buttons">
                <button type="button" class="single-deliberation-btn" data-model="gemini" title="Gemini granskar">
                  <span class="dot-google"></span> Gemini R2
                </button>
                <button type="button" class="single-deliberation-btn" data-model="anthropic" title="Claude granskar">
                  <span class="dot-anthropic"></span> Claude R2
                </button>
                <button type="button" class="single-deliberation-btn" data-model="grok" title="Grok granskar">
                  <span class="dot-grok"></span> Grok R2
                </button>
                <button type="button" class="single-deliberation-btn" data-model="openai" title="OpenAI granskar">
                  <span class="dot-openai"></span> OpenAI R2
                </button>
              </div>
            </div>
          </div>
        </section>
        
        <div id="status" class="status">
          <span class="status-dot"></span>
          <span id="statusText" class="status-text">Förbereder...</span>
        </div>
        
        <div id="error" class="error"></div>
        
        <section id="results" class="results">
          <!-- Cost banner at top -->
          <div id="costBanner" class="cost-banner">
            <div class="cost-banner-main">
              <div class="cost-banner-left">
                <span class="cost-banner-icon">💰</span>
                <span id="costBannerAmount" class="cost-banner-amount">$0.00</span>
                <span id="costBannerSek" class="cost-banner-sek">(~0 kr)</span>
              </div>
              <div class="cost-banner-right">
                <div class="cost-banner-stat">
                  <span>⏱️</span>
                  <span id="costBannerTime" class="cost-banner-stat-value">0s</span>
                </div>
                <div class="cost-banner-stat">
                  <span>📥</span>
                  <span id="costBannerTokensIn" class="cost-banner-stat-value">0</span>
                  <span>in</span>
                </div>
                <div class="cost-banner-stat">
                  <span>📤</span>
                  <span id="costBannerTokensOut" class="cost-banner-stat-value">0</span>
                  <span>out</span>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Hallucination Report (shown when deliberation is enabled) -->
          <div id="hallucinationReport" class="hallucination-report" style="display: none;">
            <div class="hallucination-header">
              <span class="hallucination-icon">🔍</span>
              <div class="hallucination-title">
                <h2>Trovärdighetsrapport</h2>
                <span id="hallucinationSubtitle">Baserat på modellernas granskning av varandra</span>
              </div>
            </div>
            <div class="hallucination-summary">
              <div id="hallucinationStatus" class="hallucination-status hallucination-status-good">
                <span class="status-icon">✅</span>
                <span class="status-text">Inga säkra fel upptäckta</span>
              </div>
              <div class="hallucination-counts">
                <div class="hallucination-count high" id="hallucinationHigh" style="display: none;">
                  <span class="count-badge">🔴</span>
                  <span class="count-num">0</span>
                  <span class="count-label">säkra</span>
                </div>
                <div class="hallucination-count medium" id="hallucinationMedium" style="display: none;">
                  <span class="count-badge">🟠</span>
                  <span class="count-num">0</span>
                  <span class="count-label">troliga</span>
                </div>
                <div class="hallucination-count low" id="hallucinationLow" style="display: none;">
                  <span class="count-badge">🟡</span>
                  <span class="count-num">0</span>
                  <span class="count-label">misstänkta</span>
                </div>
              </div>
            </div>
            <div id="hallucinationDetails" class="hallucination-details" style="display: none;">
              <button type="button" class="hallucination-toggle" id="toggleHallucinationDetails">
                <span>▼ Visa detaljer</span>
              </button>
              <div id="hallucinationList" class="hallucination-list" style="display: none;"></div>
            </div>
          </div>
          
          <div id="synthesisCard" class="synthesis-card" style="display: none;">
            <div class="synthesis-header">
              <span class="synthesis-icon">🧠</span>
              <div class="synthesis-title">
                <h2>Syntes</h2>
                <div class="synthesis-meta">
                  <span id="synthesisModelLabel">GPT-4o syntetiserar</span>
                  <span class="synthesis-meta-divider">·</span>
                  <span id="synthesisModelsUsed" class="synthesis-models-used" title="AI-modeller som ingår i syntesen"></span>
                  <span class="synthesis-meta-divider">·</span>
                  <span id="synthesisProfile" class="synthesis-profile" title="Profil/inställning"></span>
                </div>
              </div>
              <div class="synthesis-actions">
                <button type="button" class="copy-btn" id="copySynthesis" title="Kopiera">
                  <svg fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>
                  <span>Kopiera</span>
                </button>
                <button type="button" class="export-md-btn" id="exportMarkdown" title="Exportera som Markdown">
                  <svg fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>
                  <span>Export .md</span>
                </button>
                <button type="button" class="save-note-btn" id="saveSynthesis" title="Spara">
                  <svg width="14" height="14" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z" /></svg>
                  <span>Spara</span>
                </button>
                <button type="button" class="save-note-btn" id="saveToKB" title="Spara till Kunskapsbas" style="background: rgba(16, 185, 129, 0.1); border-color: #10b981; color: #10b981;">
                  <svg width="14" height="14" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" /></svg>
                  <span>→ KB</span>
                </button>
                <span id="synthesisDuration" class="synthesis-duration"></span>
              </div>
            </div>
            <div id="synthesisContent" class="synthesis-content markdown-content"></div>
          </div>
          
          <!-- Workflow progress indicator -->
          <div id="workflowProgress" class="workflow-progress" style="display: none;">
            <div class="workflow-steps">
              <div class="workflow-step" data-step="round1">
                <span class="workflow-step-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg></span>
                <span class="workflow-step-label">Runda 1</span>
              </div>
              <div class="workflow-step-arrow"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></div>
              <div class="workflow-step" data-step="synthesis1">
                <span class="workflow-step-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18h6"></path><path d="M10 22h4"></path><path d="M15.09 14c.18-.98.65-1.74 1.41-2.5A4.65 4.65 0 0 0 18 8 6 6 0 0 0 6 8c0 1 .23 2.23 1.5 3.5A4.61 4.61 0 0 1 8.91 14"></path></svg></span>
                <span class="workflow-step-label">Syntes</span>
              </div>
              <div class="workflow-step-arrow"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></div>
              <div class="workflow-step" data-step="round2">
                <span class="workflow-step-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg></span>
                <span class="workflow-step-label">Deliberation</span>
              </div>
              <div class="workflow-step-arrow"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></div>
              <div class="workflow-step" data-step="supersynthesis">
                <span class="workflow-step-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="1"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg></span>
                <span class="workflow-step-label">Supersyntes</span>
              </div>
            </div>
            <div class="workflow-info">
              <span id="workflowStatus">Väntar på svar...</span>
              <button type="button" id="resetWorkflowBtn" class="reset-workflow-btn" title="Starta om arbetsflödet">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon-inline"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>Börja om
              </button>
            </div>
          </div>
          
          <div class="responses-section">
            <div id="round1Label" class="round-label round-1" style="display: none;">Runda 1 — Initiala svar</div>
            <h3 id="responsesHeader">Individuella svar</h3>
            <!-- Responses ordered by price: cheapest → most expensive -->
            <div class="responses-grid">
              <div id="accordion-google" class="accordion google">
                <button type="button" class="accordion-header">
                  <div class="accordion-header-left">
                    <span class="accordion-dot dot-google"></span>
                    <span class="accordion-title">Gemini 2.0 Flash</span>
                    <span id="status-google" class="accordion-status"></span>
                  </div>
                  <div class="accordion-header-right">
                    <span id="duration-google" class="accordion-duration"></span>
                    <svg class="accordion-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
                  </div>
                </button>
                <div id="content-google" class="accordion-content">
                  <div class="accordion-content-inner">
                    <div class="markdown-content"></div>
                    <div class="accordion-content-actions">
                      <button type="button" class="copy-btn" data-copy="google"><svg fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg><span>Kopiera</span></button>
                    </div>
                  </div>
                </div>
              </div>
              
              <div id="accordion-anthropic" class="accordion anthropic">
                <button type="button" class="accordion-header">
                  <div class="accordion-header-left">
                    <span class="accordion-dot dot-anthropic"></span>
                    <span class="accordion-title">Claude Sonnet</span>
                    <span id="status-anthropic" class="accordion-status"></span>
                  </div>
                  <div class="accordion-header-right">
                    <span id="duration-anthropic" class="accordion-duration"></span>
                    <svg class="accordion-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
                  </div>
                </button>
                <div id="content-anthropic" class="accordion-content">
                  <div class="accordion-content-inner">
                    <div class="markdown-content"></div>
                    <div class="accordion-content-actions">
                      <button type="button" class="copy-btn" data-copy="anthropic"><svg fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg><span>Kopiera</span></button>
                    </div>
                  </div>
                </div>
              </div>
              
              <div id="accordion-grok" class="accordion grok" style="display: none;">
                <button type="button" class="accordion-header">
                  <div class="accordion-header-left">
                    <span class="accordion-dot dot-grok"></span>
                    <span class="accordion-title">Grok 4</span>
                    <span id="status-grok" class="accordion-status"></span>
                  </div>
                  <div class="accordion-header-right">
                    <span id="duration-grok" class="accordion-duration"></span>
                    <svg class="accordion-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
                  </div>
                </button>
                <div id="content-grok" class="accordion-content">
                  <div class="accordion-content-inner">
                    <div class="markdown-content"></div>
                    <div class="accordion-content-actions">
                      <button type="button" class="copy-btn" data-copy="grok"><svg fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg><span>Kopiera</span></button>
                    </div>
                  </div>
                </div>
              </div>
              
              <div id="accordion-openai" class="accordion openai">
                <button type="button" class="accordion-header">
                  <div class="accordion-header-left">
                    <span class="accordion-dot dot-openai"></span>
                    <span class="accordion-title">OpenAI o1</span>
                    <span id="status-openai" class="accordion-status"></span>
                  </div>
                  <div class="accordion-header-right">
                    <span id="duration-openai" class="accordion-duration"></span>
                    <svg class="accordion-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
                  </div>
                </button>
                <div id="content-openai" class="accordion-content">
                  <div class="accordion-content-inner">
                    <div class="markdown-content"></div>
                    <div class="accordion-content-actions">
                      <button type="button" class="copy-btn" data-copy="openai"><svg fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg><span>Kopiera</span></button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Round 2 Section (Deliberation) - ordered by price: cheapest → most expensive -->
            <div id="round2Section" style="display: none;">
              <div class="round-label">Runda 2 — Granskning & förbättring</div>
              <div class="responses-grid">
                <div id="accordion-r2-google" class="accordion google">
                  <button type="button" class="accordion-header">
                    <div class="accordion-header-left">
                      <span class="accordion-dot dot-google"></span>
                      <span class="accordion-title">Gemini (R2)</span>
                      <span id="status-r2-google" class="accordion-status"></span>
                    </div>
                    <div class="accordion-header-right">
                      <span id="duration-r2-google" class="accordion-duration"></span>
                      <svg class="accordion-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
                    </div>
                  </button>
                  <div id="content-r2-google" class="accordion-content">
                    <div class="accordion-content-inner">
                      <div class="markdown-content"></div>
                      <div class="accordion-content-actions">
                        <button type="button" class="copy-btn" data-copy="r2-google"><svg fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg><span>Kopiera</span></button>
                      </div>
                    </div>
                  </div>
                </div>
                
                <div id="accordion-r2-anthropic" class="accordion anthropic">
                  <button type="button" class="accordion-header">
                    <div class="accordion-header-left">
                      <span class="accordion-dot dot-anthropic"></span>
                      <span class="accordion-title">Claude (R2)</span>
                      <span id="status-r2-anthropic" class="accordion-status"></span>
                    </div>
                    <div class="accordion-header-right">
                      <span id="duration-r2-anthropic" class="accordion-duration"></span>
                      <svg class="accordion-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
                    </div>
                  </button>
                  <div id="content-r2-anthropic" class="accordion-content">
                    <div class="accordion-content-inner">
                      <div class="markdown-content"></div>
                      <div class="accordion-content-actions">
                        <button type="button" class="copy-btn" data-copy="r2-anthropic"><svg fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg><span>Kopiera</span></button>
                      </div>
                    </div>
                  </div>
                </div>
                
                <div id="accordion-r2-grok" class="accordion grok" style="display: none;">
                  <button type="button" class="accordion-header">
                    <div class="accordion-header-left">
                      <span class="accordion-dot dot-grok"></span>
                      <span class="accordion-title">Grok (R2)</span>
                      <span id="status-r2-grok" class="accordion-status"></span>
                    </div>
                    <div class="accordion-header-right">
                      <span id="duration-r2-grok" class="accordion-duration"></span>
                      <svg class="accordion-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
                    </div>
                  </button>
                  <div id="content-r2-grok" class="accordion-content">
                    <div class="accordion-content-inner">
                      <div class="markdown-content"></div>
                      <div class="accordion-content-actions">
                        <button type="button" class="copy-btn" data-copy="r2-grok"><svg fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg><span>Kopiera</span></button>
                      </div>
                    </div>
                  </div>
                </div>
                
                <div id="accordion-r2-openai" class="accordion openai">
                  <button type="button" class="accordion-header">
                    <div class="accordion-header-left">
                      <span class="accordion-dot dot-openai"></span>
                      <span class="accordion-title">OpenAI o1 (R2)</span>
                      <span id="status-r2-openai" class="accordion-status"></span>
                    </div>
                    <div class="accordion-header-right">
                      <span id="duration-r2-openai" class="accordion-duration"></span>
                      <svg class="accordion-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
                    </div>
                  </button>
                  <div id="content-r2-openai" class="accordion-content">
                    <div class="accordion-content-inner">
                      <div class="markdown-content"></div>
                      <div class="accordion-content-actions">
                        <button type="button" class="copy-btn" data-copy="r2-openai"><svg fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg><span>Kopiera</span></button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <div class="total-stats">
            <div class="total-duration">Total tid: <span id="totalDuration">-</span></div>
            <div class="total-cost" id="totalCostContainer" style="display: none;">
              💰 Kostnad: <span id="totalCost">-</span>
              <span class="cost-details" id="costDetails"></span>
            </div>
          </div>
        </section>
      </main>
    </div>
    
    <!-- Notes sidebar -->
    <aside id="notesSidebar" class="notes-sidebar">
      <div class="notes-header">
        <div class="notes-header-title">
          <svg width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
          Historik
        </div>
        <button type="button" class="notes-toggle" id="notesToggle" title="Minimera">
          <svg width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7" /></svg>
        </button>
      </div>
      <div class="notes-content">
        <div id="notesSync" class="notes-sync">Laddar...</div>
        <div id="notesList" class="notes-list">
          <div class="notes-empty">Inga sparade sessioner.</div>
        </div>
        <div class="notes-actions">
          <button type="button" class="notes-btn" id="exportNotes">📥 Export</button>
          <button type="button" class="notes-btn danger" id="clearNotes"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon-inline"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>Rensa</button>
        </div>
      </div>
    </aside>
    
    <!-- Mobile FAB for notes sidebar -->
    <button class="mobile-notes-fab" id="mobileNotesFab" title="Sparade sessioner">
      <svg width="24" height="24" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
      </svg>
      <span class="mobile-notes-fab-badge" id="mobileNotesBadge">0</span>
    </button>
  </div>
  
  <!-- Save prompt modal (appears after synthesis) -->
  <div id="savePromptModal" class="save-prompt-modal">
    <div class="save-prompt-content">
      <div class="save-prompt-header">
        <span class="save-prompt-icon"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg></span>
        <div class="save-prompt-title">Spara session?</div>
        <div class="save-prompt-subtitle">Din AI Council-körning är klar!</div>
      </div>
      <div class="save-prompt-body">
        <div class="save-prompt-input-group">
          <label class="save-prompt-label">Ge sessionen ett namn (valfritt)</label>
          <input type="text" id="saveSessionName" class="save-prompt-input" placeholder="T.ex. 'Litteratursökning brosk' eller 'Arkitekturbeslut SMS'">
        </div>
        <div class="save-prompt-input-group">
          <label class="save-prompt-label">Prompt (förhandsgranskning)</label>
          <div id="savePromptPreview" class="save-prompt-preview"></div>
        </div>
        <label class="save-prompt-autosave">
          <input type="checkbox" id="enableAutoSave">
          <span class="save-prompt-autosave-check">
            <svg fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7" /></svg>
          </span>
          <span class="save-prompt-autosave-text">Aktivera auto-spara (spara automatiskt efter varje körning)</span>
        </label>
      </div>
      <div class="save-prompt-footer">
        <button type="button" class="save-prompt-btn skip" id="skipSaveBtn">Hoppa över</button>
        <button type="button" class="save-prompt-btn save" id="confirmSaveBtn"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon-inline"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>Spara session</button>
      </div>
    </div>
  </div>

  <!-- Session modal -->
  <div id="sessionModal" class="session-modal">
    <div class="session-modal-content">
      <div class="session-modal-header">
        <div>
          <div class="session-modal-title">Sparad session</div>
          <div id="sessionModalMeta" class="session-modal-meta"></div>
        </div>
        <button type="button" class="session-modal-close" id="closeSessionModal">×</button>
      </div>
      <div class="session-modal-body">
        <div class="session-modal-prompt">
          <div class="session-modal-prompt-label">Prompt</div>
          <div id="sessionModalPrompt" class="session-modal-prompt-text"></div>
        </div>
        <div id="sessionModalSynthesis" class="session-modal-synthesis markdown-content"></div>
      </div>
      <div class="session-modal-footer">
        <button type="button" class="session-modal-btn" id="copySessionSynthesis">📋 Kopiera syntes</button>
        <button type="button" class="session-modal-btn" id="copySessionAll">📄 Kopiera allt</button>
        <button type="button" class="session-modal-btn" id="loadSessionPrompt">💬 Ladda prompt</button>
      </div>
    </div>
  </div>

  <!-- Project context menu -->
  <div id="projectContextMenu" class="project-context-menu">
    <button class="context-menu-item" data-action="edit">
      ✏️ Redigera projekt
    </button>
    <button class="context-menu-item" data-action="color">
      🎨 Ändra färg
    </button>
    <button class="context-menu-item" data-action="icon">
      😀 Ändra ikon
    </button>
    <button class="context-menu-item" data-action="context">
      📝 Redigera kontext
    </button>
    <div class="context-menu-divider"></div>
    <button class="context-menu-item" data-action="pin">
      📌 Fäst/ta bort
    </button>
    <div class="context-menu-divider"></div>
    <button class="context-menu-item danger" data-action="delete">
      🗑️ Ta bort projekt
    </button>
  </div>
  
  <!-- Color picker modal -->
  <div id="colorPickerModal" class="session-modal">
    <div class="session-modal-content" style="max-width: 320px;">
      <div class="session-modal-header">
        <div class="session-modal-title">Välj färg</div>
        <button type="button" class="session-modal-close" id="closeColorPicker">×</button>
      </div>
      <div class="color-picker-grid">
        <button class="color-picker-option" style="background: #2563eb;" data-color="#2563eb"></button>
        <button class="color-picker-option" style="background: #7c3aed;" data-color="#7c3aed"></button>
        <button class="color-picker-option" style="background: #db2777;" data-color="#db2777"></button>
        <button class="color-picker-option" style="background: #dc2626;" data-color="#dc2626"></button>
        <button class="color-picker-option" style="background: #ea580c;" data-color="#ea580c"></button>
        <button class="color-picker-option" style="background: #ca8a04;" data-color="#ca8a04"></button>
        <button class="color-picker-option" style="background: #16a34a;" data-color="#16a34a"></button>
        <button class="color-picker-option" style="background: #059669;" data-color="#059669"></button>
        <button class="color-picker-option" style="background: #0891b2;" data-color="#0891b2"></button>
        <button class="color-picker-option" style="background: #0284c7;" data-color="#0284c7"></button>
        <button class="color-picker-option" style="background: #6366f1;" data-color="#6366f1"></button>
        <button class="color-picker-option" style="background: #64748b;" data-color="#64748b"></button>
      </div>
    </div>
  </div>
  
  <!-- Icon picker modal -->
  <div id="iconPickerModal" class="session-modal">
    <div class="session-modal-content" style="max-width: 320px;">
      <div class="session-modal-header">
        <div class="session-modal-title">Välj ikon</div>
        <button type="button" class="session-modal-close" id="closeIconPicker">×</button>
      </div>
      <div class="icon-picker-grid">
        <button class="icon-picker-option" data-icon="📁">📁</button>
        <button class="icon-picker-option" data-icon="💻">💻</button>
        <button class="icon-picker-option" data-icon="🔬">🔬</button>
        <button class="icon-picker-option" data-icon="📊">📊</button>
        <button class="icon-picker-option" data-icon="🏥">🏥</button>
        <button class="icon-picker-option" data-icon="📝">📝</button>
        <button class="icon-picker-option" data-icon="🎯">🎯</button>
        <button class="icon-picker-option" data-icon="⚙️">⚙️</button>
        <button class="icon-picker-option" data-icon="🔧">🔧</button>
        <button class="icon-picker-option" data-icon="📱">📱</button>
        <button class="icon-picker-option" data-icon="🌐">🌐</button>
        <button class="icon-picker-option" data-icon="🔒">🔒</button>
        <button class="icon-picker-option" data-icon="💡">💡</button>
        <button class="icon-picker-option" data-icon="📚">📚</button>
        <button class="icon-picker-option" data-icon="🎨">🎨</button>
        <button class="icon-picker-option" data-icon="🚀">🚀</button>
        <button class="icon-picker-option" data-icon="⭐">⭐</button>
        <button class="icon-picker-option" data-icon="❤️">❤️</button>
      </div>
    </div>
  </div>

  <script is:inline>
    document.addEventListener('DOMContentLoaded', function() {
      console.log('🚀 AI Council script starting...');
      
      // Configure marked
      if (typeof marked !== 'undefined') {
        marked.setOptions({ breaks: true, gfm: true });
      }
      
      // State
      let currentResponses = { openai: '', anthropic: '', google: '', grok: '', synthesis: '', isSuperSynthesis: false };
      let currentPrompt = '';
      let uploadedFiles = [];
      let sessions = [];
      let useSupabase = true;
      let availableModels = { openai: true, anthropic: true, gemini: true, grok: true };
      let isRunningSequential = false; // Track if sequential run is in progress
      let isLoggedOut = false; // Track if user session has expired
      
      // ============================================
      // AUTH STATUS CHECK
      // ============================================
      const logoutBanner = document.getElementById('logoutBanner');
      let authCheckInterval = null;
      
      // Check if user is still logged in
      async function checkAuthStatus() {
        if (isLoggedOut) return false; // Already logged out, don't spam checks
        
        try {
          const res = await fetch('/api/ai-council/sessions', { 
            credentials: 'include',
            method: 'HEAD' // Lightweight check
          });
          
          // 401 means logged out
          if (res.status === 401) {
            showLogoutBanner();
            return false;
          }
          
          // Also check via actual response
          if (res.status === 200) {
            const checkRes = await fetch('/api/ai-council/sessions', { credentials: 'include' });
            const data = await checkRes.json();
            if (data.error && (data.error.includes('Ej inloggad') || data.error.includes('användare'))) {
              showLogoutBanner();
              return false;
            }
          }
          
          return true;
        } catch (e) {
          console.warn('Auth check failed:', e);
          return true; // Don't show banner on network errors
        }
      }
      
      function showLogoutBanner() {
        if (isLoggedOut) return; // Already showing
        isLoggedOut = true;
        logoutBanner?.classList.add('visible');
        document.body.classList.add('has-logout-banner');
        
        // Stop the periodic check
        if (authCheckInterval) {
          clearInterval(authCheckInterval);
          authCheckInterval = null;
        }
        
        console.warn('⚠️ Session expired - showing logout banner');
      }
      
      // Global function for dismiss button
      window.dismissLogoutBanner = function() {
        logoutBanner?.classList.remove('visible');
        document.body.classList.remove('has-logout-banner');
        // Note: isLoggedOut stays true so banner can be shown again
      };
      
      // Check auth status on page load
      checkAuthStatus();
      
      // Periodic auth check every 2 minutes
      authCheckInterval = setInterval(checkAuthStatus, 2 * 60 * 1000);
      
      // ============================================
      // SOUND NOTIFICATION
      // ============================================
      const soundNotificationEl = document.getElementById('soundNotification');
      
      function playNotificationSound(type = 'success') {
        if (!soundNotificationEl?.checked) return;
        
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          if (type === 'success') {
            // Pleasant "pling" - two ascending tones
            oscillator.frequency.setValueAtTime(523, audioContext.currentTime); // C5
            oscillator.frequency.setValueAtTime(659, audioContext.currentTime + 0.1); // E5
            oscillator.frequency.setValueAtTime(784, audioContext.currentTime + 0.2); // G5
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialDecayToValueAtTime(0.01, audioContext.currentTime + 0.4);
          } else if (type === 'error') {
            // Lower "bonk" sound
            oscillator.frequency.setValueAtTime(220, audioContext.currentTime); // A3
            oscillator.frequency.setValueAtTime(165, audioContext.currentTime + 0.1); // E3
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialDecayToValueAtTime(0.01, audioContext.currentTime + 0.3);
          } else if (type === 'complete') {
            // Triumphant chord for all done
            const osc2 = audioContext.createOscillator();
            const osc3 = audioContext.createOscillator();
            osc2.connect(gainNode);
            osc3.connect(gainNode);
            oscillator.frequency.setValueAtTime(523, audioContext.currentTime); // C5
            osc2.frequency.setValueAtTime(659, audioContext.currentTime); // E5
            osc3.frequency.setValueAtTime(784, audioContext.currentTime); // G5
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
            gainNode.gain.exponentialDecayToValueAtTime(0.01, audioContext.currentTime + 0.8);
            osc2.start(audioContext.currentTime);
            osc3.start(audioContext.currentTime);
            osc2.stop(audioContext.currentTime + 0.8);
            osc3.stop(audioContext.currentTime + 0.8);
          }
          
          oscillator.type = 'sine';
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.5);
        } catch (e) {
          console.log('Could not play notification sound:', e);
        }
      }
      
      // Per-model progress tracking
      let modelTimers = {}; // { openai: { startTime, intervalId }, ... }
      let modelStartTimes = {}; // Track when each model started
      
      // Elements
      const contextEl = document.getElementById('context');
      const promptEl = document.getElementById('prompt');
      const runBtn = document.getElementById('runBtn');
      const retryFailedBtn = document.getElementById('retryFailedBtn');
      const expandModelsBtn = document.getElementById('expandModelsBtn');
      const deliberateNowBtn = document.getElementById('deliberateNowBtn');
      const synthesizeNowBtn = document.getElementById('synthesizeNowBtn');
      const addModelsCardBtn = document.getElementById('addModelsCardBtn');
      const addModelsCount = document.getElementById('addModelsCount');
      const unusedModelDots = document.getElementById('unusedModelDots');
      const nextStepCards = document.getElementById('nextStepCards');
      const deliberateCount = document.getElementById('deliberateCount');
      const synthesizeCount = document.getElementById('synthesizeCount');
      
      // Track how many models were used for current synthesis
      let modelsInCurrentSynthesis = 0;

      // Track failed models for retry functionality
      let failedModels = [];
      let collectedResponses = {}; // Store Round 1 responses across multiple runs
      let collectedR2Responses = {}; // Store Round 2 (deliberation) responses
      let hasRunDeliberation = false; // Track if deliberation has been run
      let hasSynthesized = false; // Track if synthesis has been done
      
      // ============================================
      // PERSISTENT STORAGE - Save responses to Supabase (with localStorage fallback)
      // ============================================
      const STORAGE_KEY = 'ai-council-collected-responses';
      let saveDraftTimeout = null;
      
      // Debounced save to Supabase
      async function saveResponsesToStorage() {
        // Also save to localStorage as immediate backup
        try {
          const data = {
            responses: collectedResponses,
            r2Responses: collectedR2Responses,
            hasRunDeliberation,
            hasSynthesized,
            timestamp: Date.now()
          };
          localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        } catch (e) {
          console.warn('Could not save to localStorage:', e);
        }
        
        // Debounce Supabase saves (wait 2 seconds after last change)
        if (saveDraftTimeout) clearTimeout(saveDraftTimeout);
        saveDraftTimeout = setTimeout(async () => {
          try {
            console.log('💾 Saving draft to Supabase...');
            const response = await fetch('/api/ai-council/draft', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              credentials: 'include',
              body: JSON.stringify({
                prompt: currentPrompt,
                context: contextEl.value,
                responses: collectedResponses,
                r2Responses: collectedR2Responses,
                hasRunDeliberation
              })
            });
            
            if (response.ok) {
              console.log('✅ Draft saved to Supabase');
            } else {
              const err = await response.json();
              console.warn('Supabase save failed:', err.error);
            }
          } catch (e) {
            console.warn('Could not save to Supabase:', e);
          }
        }, 2000);
        
        console.log('💾 Saved', Object.keys(collectedResponses).length, 'responses to localStorage');
      }
      
      async function loadResponsesFromStorage() {
        // First try Supabase
        try {
          console.log('📂 Loading draft from Supabase...');
          const response = await fetch('/api/ai-council/draft', { credentials: 'include' });
          
          if (response.ok) {
            const data = await response.json();
            
            if (data.draft && data.draft.responses && Object.keys(data.draft.responses).length > 0) {
              collectedResponses = data.draft.responses || {};
              collectedR2Responses = data.draft.r2_responses || {};
              hasRunDeliberation = data.draft.has_run_deliberation || false;
              
              // Restore prompt and context if available
              if (data.draft.prompt) currentPrompt = data.draft.prompt;
              if (data.draft.prompt) promptEl.value = data.draft.prompt;
              if (data.draft.context) contextEl.value = data.draft.context;
              
              console.log('✅ Restored', Object.keys(collectedResponses).length, 'responses from Supabase');
              return true;
            }
          }
        } catch (e) {
          console.warn('Could not load from Supabase:', e);
        }
        
        // Fallback to localStorage
        try {
          const stored = localStorage.getItem(STORAGE_KEY);
          if (!stored) return false;
          
          const data = JSON.parse(stored);
          // Only restore if less than 24 hours old (localStorage is backup for Supabase)
          if (Date.now() - data.timestamp > 24 * 60 * 60 * 1000) {
            console.log('🗑️ Stored responses expired (>24h), clearing');
            localStorage.removeItem(STORAGE_KEY);
            return false;
          }
          
          collectedResponses = data.responses || {};
          collectedR2Responses = data.r2Responses || {};
          hasRunDeliberation = data.hasRunDeliberation || false;
          hasSynthesized = data.hasSynthesized || false;
          
          console.log('📂 Restored', Object.keys(collectedResponses).length, 'responses from localStorage');
          return Object.keys(collectedResponses).length > 0;
        } catch (e) {
          console.warn('Could not load from localStorage:', e);
          return false;
        }
      }
      
      async function clearStoredResponses() {
        // Clear localStorage
        localStorage.removeItem(STORAGE_KEY);
        
        // Clear Supabase draft
        try {
          await fetch('/api/ai-council/draft', { 
            method: 'DELETE', 
            credentials: 'include' 
          });
          console.log('🗑️ Cleared draft from Supabase');
        } catch (e) {
          console.warn('Could not clear Supabase draft:', e);
        }
        
        console.log('🗑️ Cleared stored responses');
      }
      
      // Update workflow progress indicator
      function updateWorkflowProgress() {
        const successCount = Object.keys(collectedResponses).length;
        const r2Count = Object.keys(collectedR2Responses).length;
        
        // Show workflow progress if we have any responses
        workflowProgress.style.display = successCount > 0 ? 'block' : 'none';
        
        // Update step states
        const steps = workflowProgress.querySelectorAll('.workflow-step');
        steps.forEach(step => {
          step.classList.remove('active', 'completed');
        });
        
        // Determine current state
        const round1Step = workflowProgress.querySelector('[data-step="round1"]');
        const synthesis1Step = workflowProgress.querySelector('[data-step="synthesis1"]');
        const round2Step = workflowProgress.querySelector('[data-step="round2"]');
        const supersynthesisStep = workflowProgress.querySelector('[data-step="supersynthesis"]');
        
        let statusText = '';
        
        if (successCount > 0) {
          round1Step.classList.add('completed');
          statusText = `${successCount} modell(er) har svarat`;
          
          if (hasSynthesized && !hasRunDeliberation) {
            synthesis1Step.classList.add('completed');
            statusText = 'Syntes klar - kan fortsätta med deliberation';
          } else if (!hasSynthesized && !hasRunDeliberation) {
            synthesis1Step.classList.add('active');
            statusText = `${successCount} svar - redo för syntes eller deliberation`;
          }
          
          if (hasRunDeliberation) {
            round1Step.classList.add('completed');
            synthesis1Step.classList.add('completed');
            round2Step.classList.add('completed');
            supersynthesisStep.classList.add('active');
            statusText = 'Deliberation klar - redo för supersyntes';
          }
          
          // If we have synthesis after deliberation
          if (hasRunDeliberation && hasSynthesized) {
            supersynthesisStep.classList.add('completed');
            statusText = '✓ Komplett arbetsflöde avslutat';
          }
        }
        
        workflowStatus.textContent = statusText;
      }
      
      // Reset workflow
      function resetWorkflow() {
        collectedResponses = {};
        collectedR2Responses = {};
        failedModels = [];
        hasRunDeliberation = false;
        clearStoredResponses(); // Clear persistent storage too
        hasSynthesized = false;
        modelsInCurrentSynthesis = 0;
        
        // Hide all workflow UI
        workflowProgress.style.display = 'none';
        round2Section.style.display = 'none';
        round1Label.style.display = 'none';
        retryFailedBtn.style.display = 'none';
        expandModelsBtn.style.display = 'none';
        nextStepCards.style.display = 'none';
        addModelsCardBtn.style.display = 'none';
        deliberateNowBtn.classList.remove('done');
        deliberateNowBtn.disabled = false;
        deliberateNowBtn.style.display = 'flex';
        synthesizeNowBtn.classList.remove('done');
        synthesizeNowBtn.disabled = false;
        // Reset synthesize card text
        synthesizeNowBtn.querySelector('.next-step-card-title').textContent = 'Sammanfattning';
        synthesizeNowBtn.querySelector('.next-step-card-desc').textContent = 'En AI sammanfattar alla svar till en slutsats';
        synthesizeNowBtn.querySelector('.next-step-card-icon').textContent = '🧪';
        const singleDelibSection = document.getElementById('singleDeliberationSection');
        if (singleDelibSection) singleDelibSection.style.display = 'none';
        // Reset single deliberation buttons
        document.querySelectorAll('.single-deliberation-btn').forEach(btn => {
          btn.classList.remove('done', 'running');
          const modelId = btn.dataset.model;
          const dotClass = { gemini: 'google', anthropic: 'anthropic', grok: 'grok', openai: 'openai' }[modelId];
          const modelName = { gemini: 'Gemini', anthropic: 'Claude', grok: 'Grok', openai: 'OpenAI' }[modelId];
          btn.innerHTML = `<span class="dot-${dotClass}"></span> ${modelName} R2`;
        });
        
        // Clear accordion contents
        document.querySelectorAll('.accordion-content .markdown-content').forEach(el => {
          el.innerHTML = '';
        });
        document.querySelectorAll('.accordion-status').forEach(el => {
          el.textContent = '';
          el.className = 'accordion-status';
        });
        document.querySelectorAll('.accordion-duration').forEach(el => {
          el.textContent = '';
        });
        
        // Reset single model buttons
        document.querySelectorAll('.single-model-btn').forEach(btn => {
          btn.disabled = false;
          btn.classList.remove('running', 'done');
          const modelId = btn.dataset.model;
          const modelEmoji = { gemini: '🟢', anthropic: '🟡', grok: '🟠', openai: '🔴' }[modelId];
          btn.innerHTML = `${modelEmoji} Kör...`;
        });
        
        // Reset results area
        document.getElementById('results').classList.remove('visible');
        document.getElementById('synthesisCard').style.display = 'none';
        document.getElementById('synthesisContent').innerHTML = '';
        document.getElementById('costBanner').classList.remove('visible');
        
        // Reset all model checkboxes to default (Gemini + Claude selected)
        document.querySelectorAll('.model-checkbox').forEach(cb => {
          const checkbox = cb.querySelector('input[type="checkbox"]');
          const modelId = cb.dataset.model;
          const shouldSelect = modelId === 'gemini' || modelId === 'anthropic';
          checkbox.checked = shouldSelect;
          cb.classList.toggle('selected', shouldSelect);
        });
        
        setStatus('🔄 Arbetsflöde återställt', true);
        setTimeout(() => setStatus('', false), 2000);
      }
      
      const statusEl = document.getElementById('status');
      const statusTextEl = document.getElementById('statusText');
      const errorEl = document.getElementById('error');
      const resultsEl = document.getElementById('results');
      const synthesisCard = document.getElementById('synthesisCard');
      const synthesisModelEl = document.getElementById('synthesisModel');
      const synthesisModelsUsedEl = document.getElementById('synthesisModelsUsed');
      const synthesisProfileEl = document.getElementById('synthesisProfile');
      const notesSidebar = document.getElementById('notesSidebar');
      const notesToggle = document.getElementById('notesToggle');
      const notesList = document.getElementById('notesList');
      const notesSync = document.getElementById('notesSync');
      const fileUploadArea = document.getElementById('fileUploadArea');
      const fileInput = document.getElementById('fileInput');
      const fileListEl = document.getElementById('fileList');
      const modelSelectionEl = document.getElementById('modelSelection');
      const deliberationToggle = document.getElementById('deliberationToggle');
      const enableDeliberationEl = document.getElementById('enableDeliberation');
      const skipSynthesisToggle = document.getElementById('skipSynthesisToggle');
      const skipSynthesisEl = document.getElementById('skipSynthesis');
      const round1Label = document.getElementById('round1Label');
      const round2Section = document.getElementById('round2Section');
      const workflowProgress = document.getElementById('workflowProgress');
      const workflowStatus = document.getElementById('workflowStatus');
      const resetWorkflowBtn = document.getElementById('resetWorkflowBtn');
      const dictationBtn = document.getElementById('dictationBtn');
      const dictationStatus = document.getElementById('dictationStatus');
      
      // Reset workflow button handler (must be after resetWorkflowBtn is defined)
      if (resetWorkflowBtn) {
        resetWorkflowBtn.addEventListener('click', () => {
          if (Object.keys(collectedResponses).length > 0) {
            if (!confirm('Vill du verkligen starta om? Alla insamlade svar kommer att försvinna.')) {
              return;
            }
          }
          resetWorkflow();
        });
      }
      
      // ============================================
      // DIKTERING / SPEECH-TO-TEXT
      // ============================================
      let recognition = null;
      let isRecording = false;
      
      function initDictation() {
        // Check browser support
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
          dictationBtn.style.display = 'none';
          console.log('Web Speech API stöds inte i denna webbläsare');
          return;
        }
        
        recognition = new SpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.lang = 'sv-SE'; // Svenska som standard
        
        let finalTranscript = '';
        let interimTranscript = '';
        
        recognition.onstart = () => {
          isRecording = true;
          dictationBtn.classList.add('recording');
          dictationStatus.textContent = '🎤 Lyssnar... (tala nu)';
          dictationStatus.className = 'dictation-status recording';
          finalTranscript = promptEl.value; // Behåll befintlig text
        };
        
        recognition.onresult = (event) => {
          interimTranscript = '';
          for (let i = event.resultIndex; i < event.results.length; i++) {
            const transcript = event.results[i][0].transcript;
            if (event.results[i].isFinal) {
              finalTranscript += (finalTranscript ? ' ' : '') + transcript;
            } else {
              interimTranscript += transcript;
            }
          }
          // Update textarea with final + interim
          promptEl.value = finalTranscript + (interimTranscript ? ' ' + interimTranscript : '');
          // Auto-scroll to bottom
          promptEl.scrollTop = promptEl.scrollHeight;
        };
        
        recognition.onerror = (event) => {
          console.error('Speech recognition error:', event.error);
          stopDictation();
          
          if (event.error === 'not-allowed') {
            dictationStatus.textContent = '❌ Mikrofon nekad. Tillåt mikrofon i webbläsaren.';
          } else if (event.error === 'no-speech') {
            dictationStatus.textContent = '⚠️ Inget tal upptäcktes. Försök igen.';
          } else if (event.error === 'network') {
            dictationStatus.textContent = '❌ Nätverksfel. Kontrollera internetanslutning.';
          } else {
            dictationStatus.textContent = `❌ Fel: ${event.error}`;
          }
          dictationStatus.className = 'dictation-status error';
        };
        
        recognition.onend = () => {
          if (isRecording) {
            // Auto-restart if still in recording mode (continuous)
            try {
              recognition.start();
            } catch (e) {
              stopDictation();
            }
          }
        };
        
        // Button click handler
        dictationBtn.addEventListener('click', toggleDictation);
      }
      
      function toggleDictation() {
        if (isRecording) {
          stopDictation();
        } else {
          startDictation();
        }
      }
      
      function startDictation() {
        if (!recognition) {
          dictationStatus.textContent = '❌ Diktering stöds inte i denna webbläsare';
          dictationStatus.className = 'dictation-status error';
          return;
        }
        
        try {
          recognition.start();
        } catch (e) {
          console.error('Could not start recognition:', e);
          dictationStatus.textContent = '❌ Kunde inte starta mikrofonen';
          dictationStatus.className = 'dictation-status error';
        }
      }
      
      function stopDictation() {
        isRecording = false;
        dictationBtn.classList.remove('recording');
        
        if (recognition) {
          try {
            recognition.stop();
          } catch (e) {
            // Ignore stop errors
          }
        }
        
        if (promptEl.value.trim()) {
          dictationStatus.textContent = '✓ Diktering klar - text tillagd';
          dictationStatus.className = 'dictation-status success';
          setTimeout(() => {
            dictationStatus.textContent = '';
          }, 3000);
        } else {
          dictationStatus.textContent = '';
        }
      }
      
      // Initialize dictation on page load
      initDictation();
      
      // ============================================
      // AUTO-RESIZE TEXTAREA
      // ============================================
      function autoResizeTextarea(textarea, minHeight = 80, maxHeight = 300) {
        textarea.style.height = 'auto';
        const newHeight = Math.min(Math.max(textarea.scrollHeight, minHeight), maxHeight);
        textarea.style.height = newHeight + 'px';
      }
      
      // Auto-resize prompt textarea on input
      promptEl.addEventListener('input', () => {
        autoResizeTextarea(promptEl, 80, 300);
      });
      
      // Auto-resize context textarea on input
      contextEl.addEventListener('input', () => {
        autoResizeTextarea(contextEl, 120, 400);
      });
      
      // Profile definitions
      const profiles = {
        snabb: {
          name: 'Snabb',
          // Only Gemini - fastest, avoids Netlify timeout (26s max on free plan)
          models: ['gemini'],
          synthesis: 'gemini',  // Gemini syntetiserar sig själv = snabbast
          deliberation: false
        },
        patient: {
          name: 'Patientfrågor',
          // Gemini + Claude - fast enough for 26s timeout
          models: ['gemini', 'anthropic'],
          synthesis: 'gpt4o',
          deliberation: false
        },
        kod: {
          name: 'Kodning',
          // All 4 models for maximum code review feedback + deliberation
          // Uses Opus 4.5 for synthesis - best for combining diverse feedback
          models: ['openai', 'anthropic', 'gemini', 'grok'],
          synthesis: 'claude-opus',
          deliberation: true
        },
        vetenskap: {
          name: 'Vetenskap',
          // Gemini (stort kontext), Claude (analys), Grok (referenser)
          // o1 som syntes för djup logisk granskning av vetenskapliga påståenden
          models: ['gemini', 'anthropic', 'grok'],
          synthesis: 'openai',
          deliberation: false  // Kan aktiveras manuellt vid behov
        },
        strategi: {
          name: 'Strategi',
          // For business decisions, investments, organizational questions
          // o1 for reasoning, Claude for structure, Grok for broad context
          models: ['openai', 'anthropic', 'grok'],
          synthesis: 'claude-opus',
          deliberation: false  // Can enable manually if needed
        }
      };
      
      let currentProfile = 'snabb';
      
      // Profile selector
      const profileSelectorEl = document.getElementById('profileSelector');
      
      function applyProfile(profileId) {
        console.log('Applying profile:', profileId);
        const profile = profiles[profileId];
        if (!profile) {
          console.error('Profile not found:', profileId);
          return;
        }
        
        currentProfile = profileId;
        console.log('Profile settings:', profile);
        
        // Update profile buttons
        profileSelectorEl.querySelectorAll('.profile-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.profile === profileId);
        });
        
        // Update model checkboxes
        modelSelectionEl.querySelectorAll('.model-checkbox').forEach(cb => {
          const model = cb.dataset.model;
          const checkbox = cb.querySelector('input');
          const shouldSelect = profile.models.includes(model) && availableModels[model];
          
          checkbox.checked = shouldSelect;
          cb.classList.toggle('selected', shouldSelect);
        });
        
        // Update synthesis model
        synthesisModelEl.value = profile.synthesis;
        
        // Update deliberation
        enableDeliberationEl.checked = profile.deliberation;
        deliberationToggle.classList.toggle('active', profile.deliberation);
      }
      
      // Helper: Update synthesis card meta info (models used + profile)
      function updateSynthesisMeta(modelsUsed) {
        // Profile names with icons
        const profileInfo = {
          'snabb': { icon: '⚡', name: 'Snabb' },
          'patient': { icon: '🩺', name: 'Patient' },
          'kod': { icon: '💻', name: 'Kodning' },
          'vetenskap': { icon: '🔬', name: 'Forskning' },
          'strategi': { icon: '🎯', name: 'Strategi' }
        };
        
        // Model display info
        const modelInfo = {
          'google': { name: 'Gemini', class: 'google' },
          'gemini': { name: 'Gemini', class: 'google' },
          'anthropic': { name: 'Claude', class: 'anthropic' },
          'grok': { name: 'Grok', class: 'grok' },
          'openai': { name: 'OpenAI', class: 'openai' },
          'OpenAI': { name: 'OpenAI', class: 'openai' },
          'Anthropic': { name: 'Claude', class: 'anthropic' },
          'Google': { name: 'Gemini', class: 'google' },
          'xAI': { name: 'Grok', class: 'grok' },
          'Grok': { name: 'Grok', class: 'grok' },
          'Grok 4': { name: 'Grok', class: 'grok' },
          'Grok 2': { name: 'Grok', class: 'grok' }
        };
        
        // Update models used display
        if (synthesisModelsUsedEl && modelsUsed && modelsUsed.length > 0) {
          const modelDotsHtml = modelsUsed.map(m => {
            const info = modelInfo[m] || { name: m, class: 'openai' };
            return `<span class="synthesis-model-dot ${info.class}" title="${info.name}"></span>`;
          }).join('');
          const modelNames = modelsUsed.map(m => (modelInfo[m] || { name: m }).name);
          // Remove duplicates
          const uniqueNames = [...new Set(modelNames)];
          synthesisModelsUsedEl.innerHTML = modelDotsHtml + ` <span>${uniqueNames.join(', ')}</span>`;
        }
        
        // Update profile display
        if (synthesisProfileEl) {
          const profile = profileInfo[currentProfile] || { icon: '⚡', name: 'Snabb' };
          synthesisProfileEl.innerHTML = `${profile.icon} ${profile.name}`;
        }
      }
      
      // Profile button click handler - using direct listeners for reliability
      profileSelectorEl.querySelectorAll('.profile-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const profileId = btn.dataset.profile;
          console.log('Profile clicked:', profileId);
          if (profileId) {
            applyProfile(profileId);
          }
        });
      });
      
      // Deliberation toggle handler
      deliberationToggle.addEventListener('click', () => {
        enableDeliberationEl.checked = !enableDeliberationEl.checked;
        deliberationToggle.classList.toggle('active', enableDeliberationEl.checked);
        
        // Clear profile selection when manually changing
        profileSelectorEl.querySelectorAll('.profile-btn').forEach(btn => btn.classList.remove('active'));
      });
      
      // Skip synthesis toggle handler (for debugging)
      skipSynthesisToggle.addEventListener('click', () => {
        skipSynthesisEl.checked = !skipSynthesisEl.checked;
        skipSynthesisToggle.classList.toggle('active', skipSynthesisEl.checked);
      });
      
      // Model checkbox handlers
      function getSelectedModels() {
        return Array.from(modelSelectionEl.querySelectorAll('.model-checkbox.selected:not(.unavailable)'))
          .map(el => el.dataset.model);
      }
      
      function updateModelCheckboxes() {
        modelSelectionEl.querySelectorAll('.model-checkbox').forEach(cb => {
          const model = cb.dataset.model;
          const isAvailable = availableModels[model];
          const checkbox = cb.querySelector('input');
          
          if (!isAvailable) {
            cb.classList.add('unavailable');
            cb.classList.remove('selected');
            checkbox.checked = false;
            checkbox.disabled = true;
          } else {
            cb.classList.remove('unavailable');
            checkbox.disabled = false;
          }
        });
      }
      
      modelSelectionEl.querySelectorAll('.model-checkbox').forEach(cb => {
        cb.addEventListener('click', (e) => {
          if (cb.classList.contains('unavailable')) return;
          
          const checkbox = cb.querySelector('input');
          checkbox.checked = !checkbox.checked;
          cb.classList.toggle('selected', checkbox.checked);
          
          // Ensure at least one is selected
          if (getSelectedModels().length === 0) {
            checkbox.checked = true;
            cb.classList.add('selected');
          }
          
          // Clear profile selection when manually changing models
          profileSelectorEl.querySelectorAll('.profile-btn').forEach(btn => btn.classList.remove('active'));
        });
      });
      
      // Clear profile when synthesis model is manually changed
      synthesisModelEl.addEventListener('change', () => {
        profileSelectorEl.querySelectorAll('.profile-btn').forEach(btn => btn.classList.remove('active'));
      });
      
      // File upload handlers
      fileUploadArea.addEventListener('click', () => fileInput.click());
      fileUploadArea.addEventListener('dragover', (e) => { e.preventDefault(); fileUploadArea.classList.add('dragover'); });
      fileUploadArea.addEventListener('dragleave', () => fileUploadArea.classList.remove('dragover'));
      fileUploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        fileUploadArea.classList.remove('dragover');
        handleFiles(e.dataTransfer.files);
      });
      fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
      
      // Camera button handler
      const cameraBtn = document.getElementById('cameraBtn');
      const cameraInput = document.getElementById('cameraInput');
      
      cameraBtn?.addEventListener('click', () => {
        cameraInput?.click();
      });
      
      cameraInput?.addEventListener('change', (e) => {
        if (e.target.files && e.target.files.length > 0) {
          handleFiles(e.target.files);
          // Reset so same photo can be taken again
          e.target.value = '';
        }
      });
      
      // Paste image handler for context and prompt textareas
      function handlePaste(e) {
        const items = e.clipboardData?.items;
        if (!items) return;
        
        let hasImage = false;
        for (const item of items) {
          if (item.type.startsWith('image/')) {
            hasImage = true;
            e.preventDefault(); // Prevent default paste behavior for images
            
            const file = item.getAsFile();
            if (file) {
              // Generate a name for pasted images
              const timestamp = new Date().toISOString().slice(11, 19).replace(/:/g, '-');
              const extension = file.type.split('/')[1] || 'png';
              const namedFile = new File([file], `inklistrad-bild-${timestamp}.${extension}`, { type: file.type });
              handleFiles([namedFile]);
            }
            break;
          }
        }
        
        // If no image, let the default paste behavior happen (for text)
      }
      
      // Add paste listeners to both textareas
      contextEl.addEventListener('paste', handlePaste);
      promptEl.addEventListener('paste', handlePaste);
      
      async function handleFiles(files) {
        for (const file of files) {
          const content = await extractFileContent(file);
          if (content) {
            uploadedFiles.push({ name: file.name, size: file.size, content });
            renderFileList();
          }
        }
      }
      
      async function extractFileContent(file) {
        const type = file.type;
        const name = file.name.toLowerCase();
        
        // Text files
        if (type.startsWith('text/') || ['.txt', '.md', '.json', '.js', '.ts', '.py', '.html', '.css'].some(ext => name.endsWith(ext))) {
          return await file.text();
        }
        
        // PDF
        if (type === 'application/pdf' || name.endsWith('.pdf')) {
          try {
            if (typeof pdfjsLib !== 'undefined') {
              pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
              const pdf = await pdfjsLib.getDocument(await file.arrayBuffer()).promise;
              let text = '';
              for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const content = await page.getTextContent();
                text += content.items.map(item => item.str).join(' ') + '\n';
              }
              return text;
            }
          } catch (e) {
            console.error('PDF parse error:', e);
          }
          return '[PDF kunde inte läsas]';
        }
        
        // Images - convert to base64 for multimodal APIs
        if (type.startsWith('image/')) {
          return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = () => {
              const base64 = reader.result;
              resolve({ 
                type: 'image', 
                base64: base64,
                mimeType: type,
                description: `[Bild: ${file.name} (${formatSize(file.size)})]`
              });
            };
            reader.onerror = () => resolve(`[Bild kunde inte läsas: ${file.name}]`);
            reader.readAsDataURL(file);
          });
        }
        
        return null;
      }
      
      function renderFileList() {
        if (uploadedFiles.length === 0) {
          fileListEl.innerHTML = '';
          return;
        }
        
        console.log('📁 renderFileList called, files:', uploadedFiles.length);
        
        // Clear and rebuild
        fileListEl.innerHTML = '';
        
        uploadedFiles.forEach((f, i) => {
          // Check if this is an image with base64 data
          const isImage = f.content && typeof f.content === 'object' && f.content.type === 'image';
          
          const fileItem = document.createElement('div');
          fileItem.className = 'file-item' + (isImage ? ' has-thumbnail' : '');
          fileItem.title = f.name;
          
          // Force container styles for thumbnails
          if (isImage) {
            fileItem.style.cssText = 'position: relative; display: inline-block; width: 96px; height: 96px;';
          }
          
          if (isImage) {
            // Image: Show thumbnail with X in corner
            const img = document.createElement('img');
            img.src = f.content.base64;
            img.className = 'file-item-thumbnail';
            img.alt = f.name;
            // Force thumbnail size with inline styles
            img.style.cssText = 'width: 96px !important; height: 96px !important; max-width: 96px !important; max-height: 96px !important; object-fit: cover; border-radius: 8px; border: 2px solid #e5e7eb; display: block;';
            fileItem.appendChild(img);
          } else {
            // Non-image: Show icon, name, size
            const icon = document.createElement('span');
            icon.className = 'file-item-icon';
            icon.textContent = '📄';
            fileItem.appendChild(icon);
            
            const name = document.createElement('span');
            name.className = 'file-item-name';
            name.textContent = f.name;
            fileItem.appendChild(name);
            
            const size = document.createElement('span');
            size.className = 'file-item-size';
            size.textContent = formatSize(f.size);
            fileItem.appendChild(size);
          }
          
          // Add remove button
          const removeBtn = document.createElement('button');
          removeBtn.className = 'file-item-remove';
          removeBtn.dataset.index = i;
          removeBtn.title = 'Ta bort';
          removeBtn.textContent = '✕';
          
          // Style remove button for thumbnails
          if (isImage) {
            removeBtn.style.cssText = 'position: absolute; top: -8px; right: -8px; width: 22px; height: 22px; background: rgba(0,0,0,0.75); border: 2px solid white; border-radius: 50%; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 11px; font-weight: bold; z-index: 5;';
          }
          
          removeBtn.addEventListener('click', () => {
            uploadedFiles.splice(i, 1);
            renderFileList();
          });
          fileItem.appendChild(removeBtn);
          
          fileListEl.appendChild(fileItem);
        });
      }
      
      function formatSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
      }
      
      // Sessions management (Supabase only - no localStorage fallback)
      let userIsLoggedIn = false;
      
      async function loadSessions() {
        notesSync.textContent = 'Laddar...';
        notesSync.className = 'notes-sync';
        
        try {
          const res = await fetch('/api/ai-council/sessions', { credentials: 'include' });
          const data = await res.json();
          
          // Handle authentication errors
          if (data.error && (data.error.includes('Ej inloggad') || data.error.includes('användare'))) {
            userIsLoggedIn = false;
            useSupabase = false;
            sessions = [];
            notesSync.textContent = '🔒 Logga in för att spara';
            notesSync.className = 'notes-sync warning';
            notesSync.title = 'Du måste vara inloggad för att spara sessioner.';
            console.warn('Auth error:', data.error);
            showLogoutBanner();
            disableSaveFeatures();
            // Check for local sessions to migrate
            checkAndOfferMigration();
          } else if (data.error && data.error.includes('ej konfigurerat')) {
            // Supabase not configured - show error
            userIsLoggedIn = false;
            useSupabase = false;
            sessions = [];
            notesSync.textContent = '❌ Ej konfigurerat';
            notesSync.className = 'notes-sync error';
            disableSaveFeatures();
          } else if (data.sessions) {
            // Successfully connected to Supabase
            userIsLoggedIn = true;
            useSupabase = true;
            sessions = data.sessions;
            notesSync.textContent = '☁️ Synkad';
            notesSync.className = 'notes-sync synced';
            enableSaveFeatures();
            // Check for local sessions to migrate
            checkAndOfferMigration();
          } else {
            // Empty but connected
            userIsLoggedIn = true;
            useSupabase = true;
            sessions = [];
            notesSync.textContent = '☁️ Redo';
            notesSync.className = 'notes-sync synced';
            enableSaveFeatures();
            // Check for local sessions to migrate
            checkAndOfferMigration();
          }
        } catch (e) {
          userIsLoggedIn = false;
          useSupabase = false;
          sessions = [];
          notesSync.textContent = '❌ Anslutningsfel';
          notesSync.className = 'notes-sync error';
          console.error('Session load error:', e);
          disableSaveFeatures();
        }
        
        renderSessions();
      }
      
      function disableSaveFeatures() {
        const saveBtn = document.getElementById('saveSessionBtn');
        if (saveBtn) {
          saveBtn.disabled = true;
          saveBtn.title = 'Logga in för att spara sessioner';
          saveBtn.style.opacity = '0.5';
          saveBtn.style.cursor = 'not-allowed';
        }
        const autoSaveCheckbox = document.getElementById('enableAutoSave');
        if (autoSaveCheckbox) {
          autoSaveCheckbox.disabled = true;
          autoSaveCheckbox.checked = false;
        }
      }
      
      function enableSaveFeatures() {
        const saveBtn = document.getElementById('saveSessionBtn');
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.title = 'Spara session';
          saveBtn.style.opacity = '1';
          saveBtn.style.cursor = 'pointer';
        }
        const autoSaveCheckbox = document.getElementById('enableAutoSave');
        if (autoSaveCheckbox) {
          autoSaveCheckbox.disabled = false;
        }
      }
      
      // Migration of old local sessions
      function checkAndOfferMigration() {
        const localSessions = JSON.parse(localStorage.getItem('ai-council-sessions') || '[]');
        if (localSessions.length === 0) return;
        
        // Remove existing migration banner if any
        document.querySelector('.migration-banner')?.remove();
        
        const banner = document.createElement('div');
        banner.className = 'migration-banner';
        banner.innerHTML = `
          <div class="migration-icon">💾</div>
          <div class="migration-text">
            <strong>${localSessions.length} lokala sessioner hittades</strong>
            <span>Dessa finns bara i denna webbläsare</span>
          </div>
          <div class="migration-actions">
            ${userIsLoggedIn ? '<button id="migrateSessions" class="btn-migrate">Spara till molnet ☁️</button>' : ''}
            <button id="discardLocalSessions" class="btn-discard">Radera</button>
          </div>
        `;
        
        const notesList = document.getElementById('notesList');
        notesList.parentNode.insertBefore(banner, notesList);
        
        if (userIsLoggedIn) {
          document.getElementById('migrateSessions')?.addEventListener('click', migrateLocalSessions);
        }
        document.getElementById('discardLocalSessions')?.addEventListener('click', discardLocalSessions);
      }
      
      async function migrateLocalSessions() {
        const localSessions = JSON.parse(localStorage.getItem('ai-council-sessions') || '[]');
        if (localSessions.length === 0) return;
        
        const btn = document.getElementById('migrateSessions');
        if (btn) {
          btn.disabled = true;
          btn.textContent = 'Migrerar...';
        }
        
        let migrated = 0, failed = 0;
        
        for (const session of localSessions) {
          try {
            // Convert responses object to array format expected by API
            let responsesArray = [];
            if (session.responses) {
              if (Array.isArray(session.responses)) {
                responsesArray = session.responses;
              } else {
                // Convert object format to array format
                for (const [key, value] of Object.entries(session.responses)) {
                  if (value && typeof value === 'object') {
                    // Map model keys to provider names
                    let provider = 'Unknown';
                    if (key.includes('gpt') || key.includes('openai') || key === 'o1' || key === 'o3') provider = 'OpenAI';
                    else if (key.includes('claude') || key.includes('anthropic')) provider = 'Anthropic';
                    else if (key.includes('gemini') || key.includes('google')) provider = 'Google';
                    else if (key.includes('grok') || key.includes('xai')) provider = 'xAI';
                    else if (key.includes('deepseek')) provider = 'DeepSeek';
                    
                    responsesArray.push({
                      ...value,
                      provider: provider,
                      model: key
                    });
                  }
                }
              }
            }
            
            const res = await fetch('/api/ai-council/sessions', {
              method: 'POST',
              credentials: 'include',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                prompt: session.prompt,
                context: session.context,
                responses: responsesArray,
                synthesis: session.synthesis,
                supersynthesis: session.supersynthesis,
                name: session.name,
                synthesisModel: session.synthesis_model
              })
            });
            if (res.ok) migrated++;
            else {
              const errData = await res.json().catch(() => ({}));
              console.error('Migration failed for session:', session.id, errData);
              failed++;
            }
          } catch (e) {
            console.error('Migration error:', e);
            failed++;
          }
        }
        
        if (failed === 0) {
          localStorage.removeItem('ai-council-sessions');
          alert('✅ ' + migrated + ' sessioner sparade till molnet!');
          document.querySelector('.migration-banner')?.remove();
        } else {
          alert(migrated + ' sparade, ' + failed + ' misslyckades. Försök igen.');
          if (btn) {
            btn.disabled = false;
            btn.textContent = 'Försök igen';
          }
        }
        
        await loadSessions();
      }
      
      function discardLocalSessions() {
        if (confirm('Är du säker? De lokala sessionerna raderas permanent och kan inte återställas.')) {
          localStorage.removeItem('ai-council-sessions');
          document.querySelector('.migration-banner')?.remove();
          alert('Lokala sessioner raderade.');
        }
      }
      
      async function saveSession(data) {
        // Require login to save
        if (!userIsLoggedIn || !useSupabase) {
          alert('Du måste vara inloggad för att spara sessioner.\n\nGå till /personal för att logga in.');
          return false;
        }
        
        try {
          const res = await fetch('/api/ai-council/sessions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify(data)
          });
          const result = await res.json();
          
          if (result.success) {
            await loadSessions();
            if (sessions.length > 0) {
              lastSavedSessionId = sessions[0].id;
              renderSessions();
              // Open sidebar if collapsed to show the new session
              if (notesSidebar.classList.contains('collapsed')) {
                notesSidebar.classList.remove('collapsed');
                localStorage.setItem('ai-council-sidebar-collapsed', 'false');
              }
              // Clear highlight after animation
              setTimeout(() => { lastSavedSessionId = null; }, 2500);
            }
            return true;
          } else {
            console.error('Save failed:', result.error);
            alert('Kunde inte spara sessionen: ' + (result.error || 'Okänt fel'));
            return false;
          }
        } catch (e) {
          console.error('Save error:', e);
          alert('Kunde inte spara sessionen. Kontrollera din internetanslutning.');
          return false;
        }
      }
      
      // Save prompt modal handlers
      const savePromptModal = document.getElementById('savePromptModal');
      const saveSessionNameInput = document.getElementById('saveSessionName');
      const savePromptPreview = document.getElementById('savePromptPreview');
      const enableAutoSaveCheckbox = document.getElementById('enableAutoSave');
      
      // Load auto-save preference from localStorage
      const autoSaveEnabled = localStorage.getItem('ai-council-autosave') === 'true';
      enableAutoSaveCheckbox.checked = autoSaveEnabled;
      
      enableAutoSaveCheckbox.addEventListener('change', () => {
        localStorage.setItem('ai-council-autosave', enableAutoSaveCheckbox.checked);
      });
      
      function showSavePromptModal() {
        saveSessionNameInput.value = '';
        savePromptPreview.textContent = currentPrompt ? currentPrompt.substring(0, 150) + (currentPrompt.length > 150 ? '...' : '') : '';
        savePromptModal.classList.add('open');
        saveSessionNameInput.focus();
      }
      
      function closeSavePromptModal() {
        savePromptModal.classList.remove('open');
      }
      
      async function saveCurrentSession(customName) {
        const name = customName || saveSessionNameInput.value.trim() || null;
        await saveSession({
          name: name,
          prompt: currentPrompt,
          context: contextEl.value,
          responses: currentResponses.rawResponses,
          synthesis: currentResponses.isSuperSynthesis ? null : currentResponses.synthesis,
          supersynthesis: currentResponses.isSuperSynthesis ? currentResponses.synthesis : null,
          synthesisModel: synthesisModelEl.value,
          totalDuration: currentResponses.totalDuration
        });
        closeSavePromptModal();
      }
      
      document.getElementById('confirmSaveBtn').addEventListener('click', () => saveCurrentSession());
      document.getElementById('skipSaveBtn').addEventListener('click', closeSavePromptModal);
      savePromptModal.addEventListener('click', (e) => { if (e.target === savePromptModal) closeSavePromptModal(); });
      document.addEventListener('keydown', (e) => { 
        if (savePromptModal.classList.contains('open')) {
          if (e.key === 'Escape') closeSavePromptModal();
          if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); saveCurrentSession(); }
        }
      });
      
      async function deleteSession(id) {
        if (!userIsLoggedIn || !useSupabase) {
          alert('Du måste vara inloggad för att radera sessioner.');
          return;
        }
        
        if (!confirm('Vill du radera denna session permanent?')) return;
        
        try {
          const res = await fetch('/api/ai-council/sessions?id=' + id, { 
            method: 'DELETE', 
            credentials: 'include' 
          });
          
          if (!res.ok) {
            const data = await res.json();
            throw new Error(data.error || 'Kunde inte radera');
          }
          
          await loadSessions();
        } catch (e) {
          console.error('Delete error:', e);
          alert('Kunde inte radera sessionen: ' + e.message);
        }
      }
      
      let lastSavedSessionId = null; // Track newly saved sessions for highlighting
      
      function renderSessions() {
        if (sessions.length === 0) {
          notesList.innerHTML = '<div class="notes-empty">Ingen historik ännu.</div>';
          return;
        }
        
        // SVG icons for consistent design
        const icons = {
          eye: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>',
          copy: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>',
          trash: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>',
          arrow: '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>',
          star: '<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="1"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>',
          lightbulb: '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18h6"></path><path d="M10 22h4"></path><path d="M15.09 14c.18-.98.65-1.74 1.41-2.5A4.65 4.65 0 0 0 18 8 6 6 0 0 0 6 8c0 1 .23 2.23 1.5 3.5A4.61 4.61 0 0 1 8.91 14"></path></svg>',
          chat: '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>'
        };
        
        notesList.innerHTML = sessions.map((s, index) => {
          const date = new Date(s.created_at);
          const timeStr = date.toLocaleString('sv-SE', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
          
          // Get best available answer and determine type class
          let answerText = '';
          let typeIcon = icons.chat;
          let typeLabel = 'Svar';
          let typeClass = 'type-response';
          if (s.supersynthesis) {
            answerText = s.supersynthesis;
            typeIcon = icons.star;
            typeLabel = 'Supersyntes';
            typeClass = 'type-supersynthesis';
          } else if (s.synthesis) {
            answerText = s.synthesis;
            typeIcon = icons.lightbulb;
            typeLabel = 'Syntes';
            typeClass = 'type-synthesis';
          } else if (s.responses) {
            const firstResponse = Object.values(s.responses)[0];
            if (firstResponse && firstResponse.content) {
              answerText = firstResponse.content;
            }
          }
          
          const promptPreview = (s.prompt || '').substring(0, 50).trim();
          const hasName = s.name && s.name.trim();
          const isNew = (index === 0 && lastSavedSessionId === s.id);
          
          return '<div class="note-item ' + typeClass + (isNew ? ' new-item' : '') + '" data-id="' + s.id + '">' +
            '<div class="note-item-header">' +
              '<span class="note-item-time">' + timeStr + '</span>' +
              '<div class="note-item-actions">' +
                '<button class="note-item-btn" data-action="view" title="Visa" aria-label="Visa session">' + icons.eye + '</button>' +
                '<button class="note-item-btn" data-action="copy" title="Kopiera" aria-label="Kopiera till urklipp">' + icons.copy + '</button>' +
                '<button class="note-item-btn" data-action="delete" title="Radera" aria-label="Radera session">' + icons.trash + '</button>' +
              '</div>' +
            '</div>' +
            (hasName ? '<div class="note-item-name">' + escapeHtml(s.name) + '</div>' : '') +
            '<div class="note-item-prompt"><span class="note-item-arrow">' + icons.arrow + '</span> ' + escapeHtml(promptPreview) + (promptPreview.length >= 50 ? '...' : '') + '</div>' +
            '<div class="note-item-type"><span class="note-item-type-icon">' + typeIcon + '</span> ' + typeLabel + '</div>' +
          '</div>';
        }).join('');
        
        notesList.querySelectorAll('.note-item-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const id = btn.closest('.note-item').dataset.id;
            const action = btn.dataset.action;
            
            if (action === 'delete') deleteSession(id);
            else if (action === 'copy') {
              const session = sessions.find(s => s.id === id);
              if (session) {
                const textToCopy = session.supersynthesis || session.synthesis || session.prompt;
                copyToClipboard(textToCopy, btn);
              }
            }
            else if (action === 'view') {
              const session = sessions.find(s => s.id === id);
              if (session) openSessionModal(session);
            }
          });
        });
        
        notesList.querySelectorAll('.note-item').forEach(item => {
          item.addEventListener('click', () => {
            const session = sessions.find(s => s.id === item.dataset.id);
            if (session) openSessionModal(session);
          });
        });
        
        // Update mobile FAB badge
        if (typeof updateNotesBadge === 'function') {
          updateNotesBadge();
        }
      }
      
      // Session modal
      let currentModalSession = null;
      const sessionModal = document.getElementById('sessionModal');
      const sessionModalPrompt = document.getElementById('sessionModalPrompt');
      const sessionModalSynthesis = document.getElementById('sessionModalSynthesis');
      const sessionModalMeta = document.getElementById('sessionModalMeta');
      
      function openSessionModal(session) {
        currentModalSession = session;
        const date = new Date(session.created_at);
        const modelLabel = { claude: '🔧 Claude', openai: '🧪 OpenAI', gemini: '📚 Gemini' }[session.synthesis_model] || session.synthesis_model;
        
        sessionModalMeta.textContent = date.toLocaleString('sv-SE') + ' • ' + modelLabel;
        sessionModalPrompt.textContent = session.prompt;
        sessionModalSynthesis.innerHTML = renderMarkdown(session.synthesis);
        sessionModal.classList.add('open');
      }
      
      function closeSessionModal() {
        sessionModal.classList.remove('open');
        currentModalSession = null;
      }
      
      document.getElementById('closeSessionModal').addEventListener('click', closeSessionModal);
      sessionModal.addEventListener('click', (e) => { if (e.target === sessionModal) closeSessionModal(); });
      document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && sessionModal.classList.contains('open')) closeSessionModal(); });
      
      document.getElementById('copySessionSynthesis').addEventListener('click', () => {
        if (currentModalSession) {
          navigator.clipboard.writeText(currentModalSession.synthesis);
          alert('Syntes kopierad!');
        }
      });
      
      document.getElementById('copySessionAll').addEventListener('click', () => {
        if (currentModalSession) {
          const text = '## Prompt\n\n' + currentModalSession.prompt + '\n\n## Syntes\n\n' + currentModalSession.synthesis;
          navigator.clipboard.writeText(text);
          alert('Prompt + syntes kopierat!');
        }
      });
      
      document.getElementById('loadSessionPrompt').addEventListener('click', () => {
        if (currentModalSession) {
          promptEl.value = currentModalSession.prompt;
          closeSessionModal();
          promptEl.focus();
        }
      });
      
      function escapeHtml(str) {
        return (str || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      }
      
      // Initialize sessions
      loadSessions();
      
      // Toggle sidebar with localStorage persistence
      const savedSidebarState = localStorage.getItem('ai-council-sidebar-collapsed');
      if (savedSidebarState === 'true') {
        notesSidebar.classList.add('collapsed');
      }
      
      notesToggle.addEventListener('click', () => {
        notesSidebar.classList.toggle('collapsed');
        localStorage.setItem('ai-council-sidebar-collapsed', notesSidebar.classList.contains('collapsed'));
      });
      
      // Export
      document.getElementById('exportNotes').addEventListener('click', () => {
        if (sessions.length === 0) { alert('Inga sessioner att exportera.'); return; }
        
        let md = '# AI Council Sessioner\n\nExporterad: ' + new Date().toLocaleString('sv-SE') + '\n\n---\n\n';
        sessions.forEach(s => {
          md += '## ' + new Date(s.created_at).toLocaleString('sv-SE') + '\n\n';
          md += '**Prompt:** ' + s.prompt + '\n\n';
          md += '**Syntes-modell:** ' + s.synthesis_model + '\n\n';
          md += s.synthesis + '\n\n---\n\n';
        });
        
        const blob = new Blob([md], { type: 'text/markdown' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'ai-council-' + new Date().toISOString().split('T')[0] + '.md';
        a.click();
      });
      
      // Clear all sessions
      document.getElementById('clearNotes').addEventListener('click', async () => {
        if (!userIsLoggedIn || !useSupabase) {
          alert('Du måste vara inloggad för att rensa sessioner.');
          return;
        }
        
        if (!confirm('Vill du radera ALLA sessioner permanent? Detta kan inte ångras.')) return;
        
        try {
          for (const s of sessions) {
            await fetch('/api/ai-council/sessions?id=' + s.id, { method: 'DELETE', credentials: 'include' });
          }
          // Also clear any remaining local sessions
          localStorage.removeItem('ai-council-sessions');
          await loadSessions();
        } catch (e) {
          console.error('Clear error:', e);
          alert('Kunde inte radera alla sessioner.');
        }
      });
      
      // Accordion toggles
      document.querySelectorAll('.accordion-header').forEach(btn => {
        btn.addEventListener('click', () => btn.closest('.accordion').classList.toggle('open'));
      });
      
      // Copy
      function copyToClipboard(text, btn) {
        navigator.clipboard.writeText(text).then(() => {
          const span = btn.querySelector('span');
          const orig = span ? span.textContent : '';
          btn.classList.add('copied');
          if (span) span.textContent = '✓';
          setTimeout(() => { btn.classList.remove('copied'); if (span) span.textContent = orig; }, 2000);
        });
      }
      
      document.querySelectorAll('.copy-btn[data-copy]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const text = currentResponses[btn.dataset.copy];
          if (text) copyToClipboard(text, btn);
        });
      });
      
      document.getElementById('copySynthesis').addEventListener('click', function() {
        if (currentResponses.synthesis) copyToClipboard(currentResponses.synthesis, this);
      });
      
      // Export as Markdown
      document.getElementById('exportMarkdown').addEventListener('click', function() {
        const hasResults = currentResponses.synthesis || (currentResponses.rawResponses && currentResponses.rawResponses.length > 0);
        if (!hasResults || !currentPrompt) {
          alert('Ingen session att exportera.');
          return;
        }
        
        const now = new Date();
        const dateStr = now.toLocaleString('sv-SE');
        const fileDate = now.toISOString().split('T')[0];
        
        // Get current profile name
        const profileSelect = document.getElementById('profileSelect');
        const profileName = profileSelect.options[profileSelect.selectedIndex].text;
        
        // Get synthesis model name
        const synthLabel = document.getElementById('synthesisModelLabel').textContent;
        
        // Get which models were used
        const usedModels = [];
        ['openai', 'anthropic', 'google', 'xai'].forEach(provider => {
          const checkbox = document.querySelector(`input[value="${provider}"]`);
          if (checkbox && checkbox.checked) {
            const label = { openai: 'OpenAI o1', anthropic: 'Claude Sonnet', google: 'Gemini 2.0 Flash', xai: 'Grok 4' }[provider];
            usedModels.push(label);
          }
        });
        
        // Get deliberation status
        const deliberationEnabled = document.getElementById('enableDeliberation').checked;
        
        // Get cost info
        const costBanner = document.getElementById('costBannerAmount');
        const costSek = document.getElementById('costBannerSek');
        const costInfo = costBanner ? `${costBanner.textContent} ${costSek ? costSek.textContent : ''}` : 'N/A';
        
        // Get duration
        const totalDuration = document.getElementById('totalDuration').textContent || 'N/A';
        
        // Build markdown
        let md = `# AI Council Session\n\n`;
        md += `**Datum:** ${dateStr}\n`;
        md += `**Profil:** ${profileName}\n`;
        md += `**Modeller:** ${usedModels.join(', ')}\n`;
        md += `**Syntesmodell:** ${synthLabel}\n`;
        md += `**Deliberation:** ${deliberationEnabled ? 'Ja (Runda 2)' : 'Nej'}\n`;
        md += `**Kostnad:** ${costInfo}\n`;
        md += `**Total tid:** ${totalDuration}\n\n`;
        
        md += `---\n\n`;
        
        md += `## Frågeställning\n\n${currentPrompt}\n\n`;
        
        // Add context if provided
        const context = document.getElementById('context').value;
        if (context && context.trim()) {
          md += `## Kontext\n\n${context.trim()}\n\n`;
        }
        
        // Add hallucination report if present
        const hallucinationReport = document.getElementById('hallucinationReport');
        if (hallucinationReport && hallucinationReport.style.display !== 'none' && deliberationEnabled) {
          const status = document.getElementById('hallucinationStatus').textContent;
          const highCount = document.querySelector('#hallucinationHigh .count-num')?.textContent || '0';
          const medCount = document.querySelector('#hallucinationMedium .count-num')?.textContent || '0';
          const lowCount = document.querySelector('#hallucinationLow .count-num')?.textContent || '0';
          
          md += `## Trovärdighetsrapport\n\n`;
          md += `**Status:** ${status}\n\n`;
          md += `| Säkerhet | Antal |\n`;
          md += `|----------|-------|\n`;
          md += `| 🔴 Hög | ${highCount} |\n`;
          md += `| 🟡 Medium | ${medCount} |\n`;
          md += `| ⚪ Låg | ${lowCount} |\n\n`;
        }
        
        md += `---\n\n`;
        
        // Add synthesis (if present)
        if (currentResponses.synthesis) {
          const synthType = deliberationEnabled ? 'SUPERSYNTES' : 'Syntes';
          md += `## ${synthType}\n\n${currentResponses.synthesis}\n\n`;
          md += `---\n\n`;
        } else {
          md += `> *Syntes hoppades över (debug-läge)*\n\n`;
          md += `---\n\n`;
        }
        
        // Add individual responses
        md += `## Individuella svar\n\n`;
        
        const modelNames = {
          openai: 'OpenAI o1',
          anthropic: 'Claude Sonnet',
          google: 'Gemini 2.0 Flash',
          grok: 'Grok 4'
        };
        
        ['openai', 'anthropic', 'google', 'grok'].forEach(provider => {
          if (currentResponses[provider]) {
            md += `### ${modelNames[provider]}\n\n`;
            md += `${currentResponses[provider]}\n\n`;
          }
        });
        
        // Add deliberation responses if present (stored as 'r2-provider')
        if (deliberationEnabled) {
          const r2Keys = { openai: 'r2-openai', anthropic: 'r2-anthropic', google: 'r2-google', grok: 'r2-grok' };
          const hasDeliberation = Object.values(r2Keys).some(k => currentResponses[k]);
          if (hasDeliberation) {
            md += `---\n\n`;
            md += `## Deliberation (Runda 2)\n\n`;
            Object.entries(r2Keys).forEach(([provider, r2Key]) => {
              if (currentResponses[r2Key]) {
                md += `### ${modelNames[provider]} - Granskning\n\n`;
                md += `${currentResponses[r2Key]}\n\n`;
              }
            });
          }
        }
        
        md += `---\n\n*Exporterad från AI Council v2.6*\n`;
        
        // Create and download file
        const blob = new Blob([md], { type: 'text/markdown' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `ai-council-${fileDate}.md`;
        a.click();
        URL.revokeObjectURL(a.href);
      });
      
      document.getElementById('saveSynthesis').addEventListener('click', async function() {
        const hasResults = currentResponses.synthesis || (currentResponses.rawResponses && currentResponses.rawResponses.length > 0);
        if (!hasResults || !currentPrompt) return;
        
        const btn = this;
        btn.disabled = true;
        
        await saveSession({
          prompt: currentPrompt,
          context: contextEl.value,
          responses: currentResponses.rawResponses,
          synthesis: currentResponses.synthesis,
          synthesisModel: synthesisModelEl.value,
          totalDuration: currentResponses.totalDuration
        });
        
        btn.classList.add('saved');
        btn.querySelector('span').textContent = 'Sparat!';
        setTimeout(() => { btn.classList.remove('saved'); btn.querySelector('span').textContent = 'Spara'; btn.disabled = false; }, 2000);
      });
      
      // Helpers
      function formatDuration(ms) { return ms < 1000 ? ms + 'ms' : (ms / 1000).toFixed(1) + 's'; }
      function renderMarkdown(content) { return typeof marked !== 'undefined' && marked.parse ? marked.parse(content || '') : '<p>' + (content || '').replace(/\n/g, '<br>') + '</p>'; }
      function setStatus(text, show) { statusEl.classList.toggle('visible', show); statusTextEl.textContent = text; }
      function showError(text) { errorEl.classList.add('visible'); errorEl.textContent = text; }
      function hideError() { errorEl.classList.remove('visible'); }
      
      // Per-model progress tracking
      function startModelWaiting(models) {
        // Clear any existing timers
        stopAllModelTimers();
        
        const modelDisplayNames = { openai: 'OpenAI o1', anthropic: 'Claude', google: 'Gemini', grok: 'Grok' };
        const modelToProvider = { openai: 'openai', anthropic: 'anthropic', gemini: 'google', grok: 'grok' };
        
        models.forEach(model => {
          const provider = modelToProvider[model] || model;
          const statusEl = document.getElementById('status-' + provider);
          const durationEl = document.getElementById('duration-' + provider);
          if (!statusEl) return;
          
          const startTime = Date.now();
          modelStartTimes[provider] = startTime;
          
          // Set initial waiting status
          statusEl.textContent = 'Väntar...';
          statusEl.className = 'accordion-status waiting';
          if (durationEl) durationEl.textContent = '0.0s';
          
          // Update timer every 100ms for smooth display
          modelTimers[provider] = setInterval(() => {
            const elapsed = (Date.now() - startTime) / 1000;
            if (durationEl) durationEl.textContent = elapsed.toFixed(1) + 's';
          }, 100);
        });
      }
      
      function stopModelTimer(provider) {
        if (modelTimers[provider]) {
          clearInterval(modelTimers[provider]);
          delete modelTimers[provider];
        }
      }
      
      function stopAllModelTimers() {
        Object.keys(modelTimers).forEach(provider => {
          clearInterval(modelTimers[provider]);
        });
        modelTimers = {};
        modelStartTimes = {};
      }
      
      function markModelComplete(provider, duration, hasError) {
        stopModelTimer(provider);
        const statusEl = document.getElementById('status-' + provider);
        if (statusEl) {
          statusEl.textContent = hasError ? '❌' : '✓';
          statusEl.className = 'accordion-status ' + (hasError ? 'error' : 'success');
        }
        const durationEl = document.getElementById('duration-' + provider);
        if (durationEl && duration) {
          durationEl.textContent = formatDuration(duration);
        }
      }
      function setLoading(loading) { runBtn.disabled = loading; runBtn.classList.toggle('loading', loading); }
      
      function displayResponse(provider, data) {
        const statusEl = document.getElementById('status-' + provider);
        const durationEl = document.getElementById('duration-' + provider);
        const contentEl = document.getElementById('content-' + provider);
        const markdownEl = contentEl.querySelector('.markdown-content');
        const accordionEl = document.getElementById('accordion-' + provider);
        const titleEl = accordionEl?.querySelector('.accordion-title');
        
        currentResponses[provider] = data.response || '';
        
        // Update accordion title with actual model name from response
        if (titleEl && data.model) {
          const modelDisplayNames = {
            'o1': 'OpenAI o1',
            'gpt-4o': 'GPT-4o',
            'claude-sonnet-4-20250514': 'Claude Sonnet 4',
            'claude-opus-4-5-20250514': 'Claude Opus 4.5',
            'gemini-2.0-flash': 'Gemini 2.0 Flash',
            'grok-4': 'Grok 4',
            'grok-2-latest': 'Grok 2',
          };
          titleEl.textContent = modelDisplayNames[data.model] || data.model;
        }
        
        // Remove waiting class before adding success/error
        statusEl.classList.remove('waiting');
        
        if (data.error) {
          statusEl.textContent = '❌';
          statusEl.classList.remove('success');
          statusEl.classList.add('error');
          markdownEl.innerHTML = '<p style="color:#f87171;">' + data.error + '</p>';
        } else {
          statusEl.textContent = '✓';
          statusEl.classList.remove('error');
          statusEl.classList.add('success');
          markdownEl.innerHTML = renderMarkdown(data.response);
        }
        
        // Display duration and cost
        let durationText = formatDuration(data.duration);
        if (data.cost && data.cost.totalCost > 0) {
          durationText += ` · $${data.cost.totalCost.toFixed(4)}`;
        }
        durationEl.textContent = durationText;
      }
      
      // Run query
      async function runQuery() {
        const context = contextEl.value.trim();
        const prompt = promptEl.value.trim();
        const synthesisModel = synthesisModelEl.value;
        const selectedModels = getSelectedModels();
        const enableDeliberation = enableDeliberationEl.checked;
        
        if (!prompt) { showError('Ange en prompt.'); return; }
        if (selectedModels.length === 0) { showError('Välj minst en AI-modell.'); return; }
        if (enableDeliberation && selectedModels.length < 2) {
          showError('Deliberation kräver minst 2 valda modeller.');
          return;
        }
        
        currentPrompt = prompt;
        hideError();
        setLoading(true);
        
        const modelNames = selectedModels.map(m => ({ openai: 'OpenAI', anthropic: 'Claude', gemini: 'Gemini', grok: 'Grok' }[m])).join(', ');
        setStatus('Runda 1: Skickar till ' + modelNames + '...', true);
        
        resultsEl.classList.remove('visible');
        synthesisCard.style.display = 'none';
        round2Section.style.display = 'none';
        round1Label.style.display = enableDeliberation ? 'block' : 'none';
        document.getElementById('costBanner').classList.remove('visible');
        
        // Reset hallucination report
        document.getElementById('hallucinationReport').style.display = 'none';
        document.getElementById('hallucinationList').innerHTML = '';
        document.getElementById('hallucinationList').style.display = 'none';
        
        currentResponses = { openai: '', anthropic: '', google: '', grok: '', 'r2-openai': '', 'r2-anthropic': '', 'r2-google': '', 'r2-grok': '', synthesis: '', rawResponses: [], totalDuration: 0 };
        
        // Hide/show Round 1 accordions based on selection
        ['openai', 'anthropic', 'google', 'grok'].forEach(p => {
          const accordion = document.getElementById('accordion-' + p);
          const r2Accordion = document.getElementById('accordion-r2-' + p);
          if (accordion) {
            const providerToModel = { openai: 'openai', anthropic: 'anthropic', google: 'gemini', grok: 'grok' };
            const isSelected = selectedModels.includes(providerToModel[p]);
            accordion.style.display = isSelected ? 'block' : 'none';
            if (r2Accordion) r2Accordion.style.display = isSelected ? 'block' : 'none';
            if (isSelected) {
              document.getElementById('status-' + p).textContent = '';
              document.getElementById('status-' + p).className = 'accordion-status';
              document.getElementById('duration-' + p).textContent = '';
              document.getElementById('content-' + p).querySelector('.markdown-content').innerHTML = '';
              accordion.classList.remove('open');
              // Clear R2 as well
              if (r2Accordion) {
                const r2Status = document.getElementById('status-r2-' + p);
                const r2Duration = document.getElementById('duration-r2-' + p);
                const r2Content = document.getElementById('content-r2-' + p);
                if (r2Status) { r2Status.textContent = ''; r2Status.className = 'accordion-status'; }
                if (r2Duration) r2Duration.textContent = '';
                if (r2Content) r2Content.querySelector('.markdown-content').innerHTML = '';
                r2Accordion.classList.remove('open');
              }
            }
          }
        });
        
        // Separate text files from images
        const textFiles = [];
        const imageFiles = [];
        
        uploadedFiles.forEach(f => {
          if (f.content && typeof f.content === 'object' && f.content.type === 'image') {
            imageFiles.push({
              name: f.name,
              base64: f.content.base64,
              mimeType: f.content.mimeType
            });
          } else {
            textFiles.push('### ' + f.name + '\n' + (typeof f.content === 'string' ? f.content : f.content?.description || ''));
          }
        });
        
        const fileContent = textFiles.join('\n\n---\n\n');
        
        // Map profile IDs to API profileType values
        const profileTypeMap = {
          snabb: 'fast',
          patient: 'patient', 
          kod: 'coding',
          vetenskap: 'science',
          strategi: 'strategy'
        };
        const profileType = profileTypeMap[currentProfile] || 'fast';
        
        try {
          // Use streaming to avoid Netlify Inactivity Timeout
          const response = await fetch('/api/ai-council/query?stream=true', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({ 
              context, 
              prompt, 
              synthesisModel, 
              fileContent, 
              selectedModels, 
              enableDeliberation, 
              profileType,
              skipSynthesis: skipSynthesisEl.checked,
              images: imageFiles.length > 0 ? imageFiles : undefined
            })
          });
          
          // Check for 401 Unauthorized first - show logout banner
          if (response.status === 401) {
            showLogoutBanner();
            throw new Error('Din session har gått ut. Logga in igen för att fortsätta.');
          }
          
          // Check for HTML error responses
          const contentType = response.headers.get('content-type') || '';
          
          if (contentType.includes('text/html') || response.status === 504) {
            const responseText = await response.text();
            console.error('API returned HTML instead of JSON:', responseText.substring(0, 500));
            
            let errorDetail = 'Okänt fel';
            if (responseText.includes('Inactivity Timeout') || response.status === 504) {
              errorDetail = '⏱️ Timeout: Serveranropet tog för lång tid. Testa att:\n• Kör lokalt (npm run dev)\n• Använd färre AI-modeller';
            } else if (responseText.includes('Not Found') || response.status === 404) {
              errorDetail = 'API-endpoint hittades inte (404).';
            } else if (responseText.includes('Unauthorized') || response.status === 401) {
              showLogoutBanner();
              errorDetail = 'Din session har gått ut. Logga in igen för att fortsätta.';
            }
            
            throw new Error(errorDetail);
          }
          
          // Handle streaming NDJSON response
          let data = null;
          
          if (contentType.includes('application/x-ndjson')) {
            // Streaming response - read line by line
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            
            while (true) {
              const { done, value } = await reader.read();
              if (done) break;
              
              buffer += decoder.decode(value, { stream: true });
              const lines = buffer.split('\n');
              buffer = lines.pop() || ''; // Keep incomplete line in buffer
              
              for (const line of lines) {
                if (!line.trim()) continue;
                
                try {
                  const event = JSON.parse(line);
                  
                  switch (event.type) {
                    case 'started':
                      setStatus('🚀 Ansluten, frågar AI-modeller...', true);
                      // Start per-model waiting indicators
                      startModelWaiting(selectedModels);
                      break;
                    case 'heartbeat':
                      // Keep-alive signal - show elapsed time in main status
                      const waitingCount = Object.keys(modelTimers).length;
                      if (waitingCount > 0) {
                        setStatus('⏳ Väntar på ' + waitingCount + ' modell' + (waitingCount > 1 ? 'er' : '') + '... (' + event.data.elapsed + 's)', true);
                      } else {
                        setStatus('⏳ Arbetar... (' + event.data.elapsed + 's)', true);
                      }
                      break;
                    case 'snapshot':
                      // Backup data in case function dies later
                      if (!data) data = { responses: [], _isSnapshot: true };
                      if (event.data.responses) data.responses = event.data.responses;
                      if (event.data.queriedModels) data.queriedModels = event.data.queriedModels;
                      if (event.data.round2Responses) data.round2Responses = event.data.round2Responses;
                      console.log('Snapshot received:', event.data.stage);
                      break;
                    case 'progress':
                      setStatus('⏳ ' + event.data.message, true);
                      break;
                    case 'model_complete':
                      // Map provider names to our internal keys
                      const providerToKey = { openai: 'openai', anthropic: 'anthropic', gemini: 'google', grok: 'grok' };
                      const modelKey = providerToKey[event.data.provider] || event.data.provider;
                      markModelComplete(modelKey, event.data.duration, event.data.hasError);
                      
                      const modelDisplayName = { openai: 'OpenAI', anthropic: 'Claude', gemini: 'Gemini', grok: 'Grok' }[event.data.provider] || event.data.provider;
                      setStatus('✓ ' + modelDisplayName + ' klar (' + formatDuration(event.data.duration) + ')', true);
                      break;
                    case 'error':
                      stopAllModelTimers();
                      throw new Error(event.data.error);
                    case 'partial_complete':
                      stopAllModelTimers();
                      // Graceful degradation - we have partial results
                      console.warn('Partial result received:', event.data.successfulModels);
                      data = event.data;
                      data._isPartial = true;
                      break;
                    case 'complete':
                      stopAllModelTimers();
                      data = event.data;
                      break;
                  }
                } catch (parseError) {
                  console.warn('Could not parse streaming event:', line, parseError);
                }
              }
            }
            
            // Process any remaining buffer
            if (buffer.trim()) {
              try {
                const event = JSON.parse(buffer);
                if (event.type === 'complete') data = event.data;
                if (event.type === 'error') throw new Error(event.data.error);
              } catch (e) {}
            }
          } else {
            // Non-streaming JSON response (fallback)
            const responseText = await response.text();
            if (responseText.startsWith('<')) {
              throw new Error('Server returnerade HTML istället för JSON');
            }
            data = JSON.parse(responseText);
          }
          
          // Handle case where stream ended without complete event but we have snapshot data
          if (!data) throw new Error('Inget svar mottaget från API');
          
          if (data._isSnapshot && !data.success) {
            // We only have snapshot data - stream was interrupted
            showError('⚠️ Anslutningen avbröts men vi har delresultat från modellerna. Se individuella svar nedan.');
            data.partialResult = true;
          }
          
          if (!response.ok && data.error && !data._isPartial && !data._isSnapshot) {
            // Check for auth errors
            if (data.error.includes('Ej inloggad') || data.error.includes('inloggad') || data.error.includes('session')) {
              showLogoutBanner();
            }
            throw new Error(data.error);
          }
          
          // Handle partial results (graceful degradation)
          if (data._isPartial || data.partialResult) {
            const successModels = data.successfulModels?.join(', ') || (data.responses?.filter(r => !r.error).map(r => r.provider).join(', ')) || 'Vissa modeller';
            showError(`⚠️ Delresultat: ${successModels} svarade, men processen avbröts. Individuella svar visas nedan.`);
          }
          
          // Update available models from API response
          if (data.availableModels) {
            data.availableModels.forEach(m => { availableModels[m.model] = m.available; });
            updateModelCheckboxes();
          }
          
          resultsEl.classList.add('visible');
          currentResponses.rawResponses = data.responses;
          currentResponses.totalDuration = data.totalDuration;
          
          // Display Round 1 responses
          // Note: Grok API returns 'Grok 4' or 'Grok 2' as provider, not 'xAI'
          const providerMap = { 'OpenAI': 'openai', 'Anthropic': 'anthropic', 'Google': 'google', 'xAI': 'grok', 'Grok 4': 'grok', 'Grok 2': 'grok', 'Grok': 'grok' };
          data.responses.forEach(r => { const key = providerMap[r.provider]; if (key) displayResponse(key, r); });
          
          // Display Round 2 responses if deliberation was enabled
          if (data.deliberationEnabled && data.round2Responses) {
            setStatus('Runda 2: Modellerna granskar varandra...', true);
            round2Section.style.display = 'block';
            
            data.round2Responses.forEach(r => {
              const key = providerMap[r.provider];
              if (key) {
                displayResponse('r2-' + key, r);
              }
            });
          }
          
          const synthLabel = { 
            claude: 'Claude Sonnet', 
            'claude-opus': 'Claude Opus 4.5', 
            openai: 'OpenAI o1', 
            gpt4o: 'GPT-4o',
            gemini: 'Gemini', 
            grok: 'Grok' 
          }[data.synthesisModel || synthesisModel];
          const synthType = data.deliberationEnabled ? 'Supersyntes' : 'Syntes';
          setStatus(synthType + ' med ' + synthLabel + '...', true);
          
          if (data.synthesis) {
            currentResponses.synthesis = data.synthesis.response || '';
            currentResponses.isSuperSynthesis = !!data.deliberationEnabled;
            synthesisCard.style.display = 'block';
            
            let synthDuration = formatDuration(data.synthesis.duration);
            if (data.synthesis.cost && data.synthesis.cost.totalCost > 0) {
              synthDuration += ` · $${data.synthesis.cost.totalCost.toFixed(4)}`;
            }
            document.getElementById('synthesisDuration').textContent = synthDuration;
            document.getElementById('synthesisContent').innerHTML = renderMarkdown(data.synthesis.response);
            document.getElementById('synthesisModelLabel').textContent = data.synthesis.provider;
            
            // Update synthesis meta info (which models were used + profile)
            const modelsUsed = data.responses ? data.responses.filter(r => !r.error).map(r => r.provider) : selectedModels;
            updateSynthesisMeta(modelsUsed);
          }
          
          document.getElementById('totalDuration').textContent = formatDuration(data.totalDuration);
          
          // Display cost information (banner at top + details at bottom)
          if (data.totalCost && data.totalCost.totalCostUSD > 0) {
            const costContainer = document.getElementById('totalCostContainer');
            const costEl = document.getElementById('totalCost');
            const detailsEl = document.getElementById('costDetails');
            
            const usdCost = data.totalCost.totalCostUSD;
            const sekCost = usdCost * 10.5; // Approximate USD to SEK
            
            costEl.textContent = `$${usdCost.toFixed(4)} (~${sekCost.toFixed(2)} kr)`;
            detailsEl.textContent = `${data.totalCost.inputTokens.toLocaleString()} in / ${data.totalCost.outputTokens.toLocaleString()} ut tokens`;
            costContainer.style.display = 'block';
            
            // Update cost banner at top
            const costBanner = document.getElementById('costBanner');
            document.getElementById('costBannerAmount').textContent = `$${usdCost.toFixed(4)}`;
            document.getElementById('costBannerSek').textContent = `(~${sekCost.toFixed(2)} kr)`;
            document.getElementById('costBannerTime').textContent = formatDuration(data.totalDuration);
            document.getElementById('costBannerTokensIn').textContent = data.totalCost.inputTokens.toLocaleString();
            document.getElementById('costBannerTokensOut').textContent = data.totalCost.outputTokens.toLocaleString();
            costBanner.classList.add('visible');
          }
          
          // Display hallucination report (only if deliberation was enabled)
          const hallucinationReport = document.getElementById('hallucinationReport');
          if (data.hallucinationReport && data.deliberationEnabled) {
            const report = data.hallucinationReport;
            hallucinationReport.style.display = 'block';
            
            // Update counts
            const highEl = document.getElementById('hallucinationHigh');
            const mediumEl = document.getElementById('hallucinationMedium');
            const lowEl = document.getElementById('hallucinationLow');
            const statusEl = document.getElementById('hallucinationStatus');
            
            if (report.high > 0) {
              highEl.style.display = 'flex';
              highEl.querySelector('.count-num').textContent = report.high;
            } else {
              highEl.style.display = 'none';
            }
            
            if (report.medium > 0) {
              mediumEl.style.display = 'flex';
              mediumEl.querySelector('.count-num').textContent = report.medium;
            } else {
              mediumEl.style.display = 'none';
            }
            
            if (report.low > 0) {
              lowEl.style.display = 'flex';
              lowEl.querySelector('.count-num').textContent = report.low;
            } else {
              lowEl.style.display = 'none';
            }
            
            // Update status message and styling
            if (report.high > 0) {
              statusEl.className = 'hallucination-status hallucination-status-danger';
              statusEl.innerHTML = '<span class="status-icon">🔴</span><span class="status-text">' + report.high + ' säkra fel upptäckta</span>';
              hallucinationReport.className = 'hallucination-report has-high';
            } else if (report.medium > 0) {
              statusEl.className = 'hallucination-status hallucination-status-warning';
              statusEl.innerHTML = '<span class="status-icon">🟠</span><span class="status-text">' + report.medium + ' troliga fel upptäckta</span>';
              hallucinationReport.className = 'hallucination-report has-issues';
            } else if (report.low > 0) {
              statusEl.className = 'hallucination-status hallucination-status-warning';
              statusEl.innerHTML = '<span class="status-icon">🟡</span><span class="status-text">' + report.low + ' misstänkta påståenden</span>';
              hallucinationReport.className = 'hallucination-report has-issues';
            } else {
              statusEl.className = 'hallucination-status hallucination-status-good';
              statusEl.innerHTML = '<span class="status-icon">✅</span><span class="status-text">Inga uppenbara fel upptäckta</span>';
              hallucinationReport.className = 'hallucination-report';
            }
            
            // Show details toggle if there are items
            const detailsSection = document.getElementById('hallucinationDetails');
            const listEl = document.getElementById('hallucinationList');
            if (report.items && report.items.length > 0) {
              detailsSection.style.display = 'block';
              listEl.innerHTML = report.items.map(item => {
                const confidenceClass = item.confidence;
                const badge = item.confidence === 'high' ? '🔴' : item.confidence === 'medium' ? '🟠' : '🟡';
                return `
                  <div class="hallucination-item ${confidenceClass}">
                    <div class="hallucination-item-header">
                      <span>${badge}</span>
                      <span style="color: #fff; font-weight: 500;">Flaggad av ${item.flaggedBy}</span>
                    </div>
                    <div class="hallucination-item-claim">"${item.claim}"</div>
                    <div class="hallucination-item-meta">
                      <span>Källa: ${item.source}</span>
                      <span>Anledning: ${item.reason}</span>
                    </div>
                  </div>
                `;
              }).join('');
            } else {
              detailsSection.style.display = 'none';
            }
          } else {
            hallucinationReport.style.display = 'none';
          }
          
          setStatus('', false);
          
          // Track failed models and successful responses for incremental workflow
          // Map API provider names to checkbox data-model values
          const providerToModel = { 
            'OpenAI': 'openai', 
            'Anthropic': 'anthropic', 
            'Google': 'gemini', 
            'Grok 4': 'grok', 
            'Grok 2': 'grok', 
            'Grok': 'grok',
            'xAI': 'grok' 
          };
          failedModels = [];
          
          data.responses.forEach(r => {
            const modelKey = providerToModel[r.provider] || r.provider.toLowerCase();
            // Check for error OR empty/missing response (like the Grok bug showed)
            const hasFailed = r.error || !r.response || r.response.trim() === '';
            if (hasFailed) {
              // Avoid duplicates (e.g. if both 'Grok 4' and 'Grok 2' failed)
              if (!failedModels.includes(modelKey)) {
                failedModels.push(modelKey);
              }
            } else {
              // Store successful response
              collectedResponses[modelKey] = r;
              saveResponsesToStorage(); // Persist immediately!
            }
          });
          
          console.log('Failed models:', failedModels, 'Collected:', Object.keys(collectedResponses));
          
          // Show/hide workflow buttons based on state
          // NEW: Always show incremental buttons when we have responses (not just in skip-synthesis mode)
          const hasFailures = failedModels.length > 0;
          const successCount = Object.keys(collectedResponses).length;
          const hasSuccesses = successCount > 0;
          const hasSynthesis = !!data.synthesis;
          const isSkipSynthesis = data.skipSynthesis || skipSynthesisEl.checked;
          const hasDeliberation = data.deliberationEnabled || hasRunDeliberation;
          
          // Show retry button if there are failed models
          retryFailedBtn.style.display = hasFailures ? 'flex' : 'none';
          if (hasFailures) {
            retryFailedBtn.querySelector('span').textContent = `🔄 Försök igen (${failedModels.length} misslyckade)`;
          }
          
          // Show "expand" button to add more models (use helper function for consistent key mapping)
          const unusedModelsForBtn = getUnusedModels();
          expandModelsBtn.style.display = (hasSuccesses && unusedModelsForBtn.length > 0) ? 'flex' : 'none';
          if (unusedModelsForBtn.length > 0) {
            expandModelsBtn.querySelector('span').textContent = `➕ Lägg till modeller (${unusedModelsForBtn.length} kvar)`;
          }
          
          // Calculate what options are available
          const unusedModels = ['gemini', 'anthropic', 'grok', 'openai'].filter(m => {
            const providerKey = m === 'gemini' ? 'google' : m;
            return !collectedResponses[providerKey];
          });
          const hasUnusedModels = unusedModels.length > 0;
          const canAddModels = hasSuccesses && hasUnusedModels;
          
          // Check if new models have been added since last synthesis
          const newModelsAddedSinceSynthesis = hasSynthesis && (successCount > modelsInCurrentSynthesis);
          
          // Deliberation: requires 2+ responses, not already done
          const canRunDeliberation = successCount >= 2 && !hasDeliberation;
          
          // Synthesis: can run if we have responses AND (no synthesis yet OR new models were added)
          const canSynthesize = hasSuccesses && (!hasSynthesis || newModelsAddedSinceSynthesis);
          
          // Show the cards container if ANY option is available
          const shouldShowCards = canRunDeliberation || canSynthesize || canAddModels;
          nextStepCards.style.display = shouldShowCards ? 'block' : 'none';
          
          // Update "Lägg till modeller" card
          addModelsCardBtn.style.display = canAddModels ? 'flex' : 'none';
          if (canAddModels) {
            addModelsCount.textContent = `${unusedModels.length} kvar`;
            // Show colored dots for unused models
            const dotColors = { gemini: '#10b981', anthropic: '#f59e0b', grok: '#3b82f6', openai: '#6b7280' };
            unusedModelDots.innerHTML = unusedModels.map(m => 
              `<span class="model-dot-unused" style="background: ${dotColors[m]}" title="${m}"></span>`
            ).join('');
          }
          
          // Update deliberation card
          deliberateNowBtn.disabled = !canRunDeliberation;
          deliberateNowBtn.classList.toggle('done', hasDeliberation);
          deliberateCount.textContent = `${successCount} svar`;
          
          // Update synthesize card
          synthesizeNowBtn.disabled = !canSynthesize;
          synthesizeNowBtn.classList.toggle('done', hasSynthesis && !newModelsAddedSinceSynthesis);
          synthesizeCount.textContent = hasDeliberation ? `${successCount}+R2 svar` : `${successCount} svar`;
          
          // Update card descriptions based on state
          if (newModelsAddedSinceSynthesis) {
            synthesizeNowBtn.querySelector('.next-step-card-title').textContent = 'Uppdatera syntes';
            synthesizeNowBtn.querySelector('.next-step-card-desc').textContent = `Kör ny syntes med alla ${successCount} svar (${successCount - modelsInCurrentSynthesis} nya)`;
            synthesizeNowBtn.querySelector('.next-step-card-icon').textContent = '🔄';
          } else if (hasDeliberation) {
            synthesizeNowBtn.querySelector('.next-step-card-title').textContent = 'Supersyntes';
            synthesizeNowBtn.querySelector('.next-step-card-desc').textContent = 'Sammanfatta efter faktagranskning – högre kvalitet';
            synthesizeNowBtn.querySelector('.next-step-card-icon').textContent = '🧪';
          } else {
            synthesizeNowBtn.querySelector('.next-step-card-title').textContent = 'Sammanfattning';
            synthesizeNowBtn.querySelector('.next-step-card-desc').textContent = 'En AI sammanfattar alla svar till en slutsats';
            synthesizeNowBtn.querySelector('.next-step-card-icon').textContent = '🧪';
          }
          
          // Also show single-model deliberation section
          const singleDelibSection = document.getElementById('singleDeliberationSection');
          if (singleDelibSection) singleDelibSection.style.display = canRunDeliberation ? 'block' : 'none';
          
          // Update hasSynthesized flag if synthesis was included
          if (hasSynthesis) {
            hasSynthesized = true;
            modelsInCurrentSynthesis = successCount;
          }
          
          // Update workflow progress indicator
          updateWorkflowProgress();
          
          // Show save prompt or auto-save (works even without synthesis in debug mode)
          const hasResults = currentResponses.synthesis || (currentResponses.rawResponses && currentResponses.rawResponses.length > 0);
          if (hasResults) {
            if (localStorage.getItem('ai-council-autosave') === 'true') {
              // Auto-save with timestamp as name
              await saveCurrentSession('Auto: ' + new Date().toLocaleString('sv-SE'));
            } else {
              // Show save prompt modal
              setTimeout(() => showSavePromptModal(), 500);
            }
          }
        } catch (error) {
          showError(error.message);
          setStatus('', false);
        } finally {
          stopAllModelTimers();
          setLoading(false);
        }
      }

      // Retry failed models button handler
      retryFailedBtn.addEventListener('click', async () => {
        if (failedModels.length === 0) {
          console.log('No failed models to retry');
          return;
        }
        
        console.log('Retrying failed models:', failedModels);
        
        // Select only the failed models (using data-model attribute)
        document.querySelectorAll('.model-checkbox').forEach(cb => {
          const checkbox = cb.querySelector('input[type="checkbox"]');
          const modelId = cb.dataset.model; // Use data-model attribute
          const shouldSelect = failedModels.includes(modelId);
          console.log(`Model ${modelId}: shouldSelect=${shouldSelect}, failed=${failedModels.includes(modelId)}`);
          checkbox.checked = shouldSelect;
          cb.classList.toggle('selected', shouldSelect);
        });
        
        // Enable skip synthesis for incremental collection
        skipSynthesisEl.checked = true;
        skipSynthesisToggle.classList.add('active');
        
        // Run the query automatically
        await runQuery();
      });
      
      // Helper function to get unused models
      function getUnusedModels() {
        return ['gemini', 'anthropic', 'grok', 'openai'].filter(m => {
          const providerKey = m === 'gemini' ? 'google' : m;
          return !collectedResponses[providerKey];
        });
      }
      
      // Helper function to prepare and run additional models
      function prepareToAddModels() {
        const unusedModels = getUnusedModels();
        
        if (unusedModels.length === 0) {
          alert('Alla modeller har redan svarat.');
          return;
        }
        
        // Update checkboxes: deselect models that already have responses, select unused ones
        document.querySelectorAll('.model-checkbox').forEach(cb => {
          const checkbox = cb.querySelector('input[type="checkbox"]');
          const modelId = cb.dataset.model;
          const isUnused = unusedModels.includes(modelId);
          checkbox.checked = isUnused;
          cb.classList.toggle('selected', isUnused);
        });
        
        // Enable skip synthesis for incremental collection
        skipSynthesisEl.checked = true;
        skipSynthesisToggle.classList.add('active');
        
        // Scroll to run button and highlight it
        runBtn.scrollIntoView({ behavior: 'smooth', block: 'center' });
        runBtn.classList.add('highlight-pulse');
        setTimeout(() => runBtn.classList.remove('highlight-pulse'), 2000);
        
        // Show info message
        setStatus(`✓ ${unusedModels.length} modeller valda. Klicka "Kör AI Council" för att lägga till.`, true);
      }
      
      // Expand models button handler - add more models to existing responses
      expandModelsBtn.addEventListener('click', prepareToAddModels);
      
      // "Lägg till modeller" card button handler (in next-step-cards)
      addModelsCardBtn.addEventListener('click', prepareToAddModels);
      
      // Deliberation button handler - run Round 2 on collected responses
      deliberateNowBtn.addEventListener('click', async () => {
        const responses = Object.values(collectedResponses);
        if (responses.length < 2) {
          alert('Deliberation kräver minst 2 svar.');
          return;
        }
        
        // IMPORTANT: Ensure currentPrompt is set (fallback to input field)
        if (!currentPrompt) {
          currentPrompt = promptEl.value.trim();
        }
        if (!currentPrompt) {
          alert('Prompt saknas. Skriv in din fråga igen.');
          return;
        }
        
        setLoading(true);
        setStatus('🔄 Kör deliberation - modellerna granskar varandras svar...', true);
        
        // Show Round 2 section
        round2Section.style.display = 'block';
        round1Label.style.display = 'block';
        
        // Start waiting indicators for R2
        const modelsWithResponses = Object.keys(collectedResponses);
        modelsWithResponses.forEach(modelKey => {
          const r2StatusEl = document.getElementById('status-r2-' + modelKey);
          const r2DurationEl = document.getElementById('duration-r2-' + modelKey);
          const r2Accordion = document.getElementById('accordion-r2-' + modelKey);
          if (r2Accordion) r2Accordion.style.display = 'block';
          if (r2StatusEl) {
            r2StatusEl.textContent = 'Väntar...';
            r2StatusEl.className = 'accordion-status waiting';
          }
          if (r2DurationEl) r2DurationEl.textContent = '0.0s';
        });
        
        try {
          const response = await fetch('/api/ai-council/deliberate-only', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              prompt: currentPrompt,
              responses: responses
            })
          });
          
          if (!response.ok) {
            throw new Error('Deliberationsfel: ' + response.statusText);
          }
          
          const data = await response.json();
          
          if (data.round2Responses) {
            // Store R2 responses
            const providerToKey = { 
              'OpenAI': 'openai', 
              'Anthropic': 'anthropic', 
              'Google': 'google', 
              'Grok 4': 'grok', 
              'Grok 2': 'grok',
              'Grok': 'grok',
              'xAI': 'grok' 
            };
            
            data.round2Responses.forEach(r => {
              const key = providerToKey[r.provider] || r.provider.toLowerCase();
              collectedR2Responses[key] = r;
              displayResponse('r2-' + key, r);
            });
            
            hasRunDeliberation = true;
            
            // Update cards - mark deliberation done, enable supersyntes
            deliberateNowBtn.classList.add('done');
            deliberateNowBtn.disabled = true;
            const singleDelibSectionFull = document.getElementById('singleDeliberationSection');
            if (singleDelibSectionFull) singleDelibSectionFull.style.display = 'none';
            
            // Update syntes card to show supersyntes
            synthesizeNowBtn.disabled = false;
            synthesizeNowBtn.querySelector('.next-step-card-title').textContent = 'Supersyntes';
            synthesizeNowBtn.querySelector('.next-step-card-desc').textContent = 'Sammanfatta efter faktagranskning – högre kvalitet';
            synthesizeCount.textContent = `${Object.keys(collectedResponses).length}+R2 svar`;
            
            // Update workflow progress
            updateWorkflowProgress();
            
            setStatus('✓ Faktagranskning klar! Kör supersyntes.', true);
            setTimeout(() => setStatus('', false), 3000);
          }
        } catch (error) {
          showError('Fel vid faktagranskning: ' + error.message + '. Försök igen.');
          setStatus('', false);
          // Re-enable deliberation button
          deliberateNowBtn.disabled = false;
        } finally {
          setLoading(false);
        }
      });
      
      // Single-model deliberation buttons - run ONE model's deliberation at a time
      const singleDeliberationSection = document.getElementById('singleDeliberationSection');
      document.querySelectorAll('.single-deliberation-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
          const modelId = btn.dataset.model;
          const responses = Object.values(collectedResponses);
          
          if (responses.length < 2) {
            alert('Deliberation kräver minst 2 R1-svar.');
            return;
          }
          
          // IMPORTANT: Ensure currentPrompt is set (fallback to input field)
          if (!currentPrompt) {
            currentPrompt = promptEl.value.trim();
          }
          if (!currentPrompt) {
            alert('Prompt saknas. Skriv in din fråga igen.');
            return;
          }
          
          // Disable all deliberation buttons while running
          document.querySelectorAll('.single-deliberation-btn').forEach(b => b.disabled = true);
          deliberateNowBtn.disabled = true;
          btn.classList.add('running');
          const originalText = btn.innerHTML;
          btn.textContent = '⏳ Kör...';
          
          const modelNames = { gemini: 'Gemini', anthropic: 'Claude', grok: 'Grok', openai: 'OpenAI' };
          setStatus(`🔄 ${modelNames[modelId]} granskar andras svar...`, true);
          hideError();
          
          // Show Round 2 section
          round2Section.style.display = 'block';
          round1Label.style.display = 'block';
          
          // Show and prepare the R2 accordion for this model
          const providerMap = { gemini: 'google', anthropic: 'anthropic', grok: 'grok', openai: 'openai' };
          const providerId = providerMap[modelId];
          const r2Accordion = document.getElementById('accordion-r2-' + providerId);
          if (r2Accordion) {
            r2Accordion.style.display = 'block';
            const r2StatusEl = document.getElementById('status-r2-' + providerId);
            const r2DurationEl = document.getElementById('duration-r2-' + providerId);
            if (r2StatusEl) {
              r2StatusEl.textContent = 'Kör...';
              r2StatusEl.className = 'accordion-status waiting';
            }
            if (r2DurationEl) r2DurationEl.textContent = '0.0s';
          }
          
          try {
            console.log(`🔄 Running single deliberation: ${modelId}`);
            
            const response = await fetch('/api/ai-council/deliberate-only', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                prompt: currentPrompt,
                responses: responses,
                selectedModel: modelId
              })
            });
            
            if (!response.ok) {
              throw new Error('Deliberationsfel: ' + response.statusText);
            }
            
            const data = await response.json();
            
            if (data.round2Responses && data.round2Responses.length > 0) {
              const r2Response = data.round2Responses[0];
              
              // Store R2 response
              collectedR2Responses[providerId] = r2Response;
              
              // Display the response
              displayResponse('r2-' + providerId, r2Response);
              
              // Mark button as done
              btn.classList.remove('running');
              btn.classList.add('done');
              btn.innerHTML = `<span class="dot-${providerId === 'google' ? 'google' : providerId}"></span> ✓ ${modelNames[modelId]} R2`;
              
              // Update counters
              const r2Count = Object.keys(collectedR2Responses).length;
              const r1Count = Object.keys(collectedResponses).length;
              
              setStatus(`✓ ${modelNames[modelId]} R2 klar! (${r2Count}/${r1Count} deliberationer)`, true);
              
              // Play success sound
              playNotificationSound('success');
              
              // If all models have deliberated, update state
              if (r2Count >= r1Count) {
                playNotificationSound('complete');
                hasRunDeliberation = true;
                deliberateNowBtn.classList.add('done');
                deliberateNowBtn.disabled = true;
                singleDeliberationSection.style.display = 'none';
                synthesizeNowBtn.disabled = false;
                synthesizeNowBtn.querySelector('.next-step-card-title').textContent = 'Supersyntes';
                synthesizeNowBtn.querySelector('.next-step-card-desc').textContent = 'Sammanfatta efter faktagranskning – högre kvalitet';
                synthesizeCount.textContent = `${r1Count}+R2 svar`;
                setStatus('✓ All faktagranskning klar! Kör supersyntes.', true);
              } else {
                // Update syntes card to show partial progress
                synthesizeNowBtn.disabled = false;
                synthesizeCount.textContent = `${r2Count}/${r1Count} R2`;
              }
              
              // Update workflow progress
              updateWorkflowProgress();
              
              // Save to storage
              saveResponsesToStorage();
            }
            
          } catch (error) {
            console.error('Single deliberation error:', error);
            showError(`${modelNames[modelId]} R2 fel: ${error.message}`);
            playNotificationSound('error');
            if (r2Accordion) {
              const r2StatusEl = document.getElementById('status-r2-' + providerId);
              if (r2StatusEl) {
                r2StatusEl.textContent = 'Fel';
                r2StatusEl.className = 'accordion-status error';
              }
            }
            btn.classList.remove('running');
          } finally {
            // Re-enable buttons
            document.querySelectorAll('.single-deliberation-btn').forEach(b => {
              b.disabled = false;
            });
            deliberateNowBtn.disabled = false;
            setTimeout(() => setStatus('', false), 3000);
          }
        });
      });
      
      // Synthesize now button handler
      synthesizeNowBtn.addEventListener('click', async () => {
        const responses = Object.values(collectedResponses);
        if (responses.length === 0) {
          alert('Inga svar att syntetisera.');
          return;
        }
        
        // IMPORTANT: Ensure currentPrompt is set (fallback to input field)
        if (!currentPrompt) {
          currentPrompt = promptEl.value.trim();
        }
        if (!currentPrompt) {
          alert('Prompt saknas. Skriv in din fråga igen.');
          return;
        }
        
        // Determine if this is super-synthesis (with R2 responses) or regular synthesis
        const r2Responses = Object.values(collectedR2Responses);
        const isSuperSynthesis = hasRunDeliberation && r2Responses.length > 0;
        
        setLoading(true);
        setStatus(isSuperSynthesis ? '🧪 Kör supersyntes...' : '🧪 Kör syntes på insamlade svar...', true);
        
        try {
          const response = await fetch('/api/ai-council/synthesize-only', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              prompt: currentPrompt,
              responses: responses,
              round2Responses: isSuperSynthesis ? r2Responses : undefined,
              synthesisModel: synthesisModelEl.value,
              isSuperSynthesis
            })
          });
          
          if (!response.ok) {
            throw new Error('Syntesfel: ' + response.statusText);
          }
          
          const data = await response.json();
          
          if (data.synthesis) {
            currentResponses.synthesis = data.synthesis.response || '';
            currentResponses.isSuperSynthesis = hasRunDeliberation;
            synthesisCard.style.display = 'block';
            
            let synthDuration = formatDuration(data.synthesis.duration);
            if (data.synthesis.cost && data.synthesis.cost.totalCost > 0) {
              synthDuration += ` · $${data.synthesis.cost.totalCost.toFixed(4)}`;
            }
            document.getElementById('synthesisDuration').textContent = synthDuration;
            document.getElementById('synthesisContent').innerHTML = renderMarkdown(data.synthesis.response);
            document.getElementById('synthesisModelLabel').textContent = data.synthesis.provider;
            
            // Update synthesis meta info (which models were used + profile)
            const modelsUsed = Object.keys(collectedResponses);
            updateSynthesisMeta(modelsUsed);
            
            // Mark synthesize as done and track model count
            hasSynthesized = true;
            modelsInCurrentSynthesis = Object.keys(collectedResponses).length;
            
            // Update cards to show remaining options (e.g., add more models)
            const unusedModels = ['gemini', 'anthropic', 'grok', 'openai'].filter(m => {
              const providerKey = m === 'gemini' ? 'google' : m;
              return !collectedResponses[providerKey];
            });
            
            if (unusedModels.length > 0) {
              // Show "add models" card if there are unused models
              synthesizeNowBtn.classList.add('done');
              synthesizeNowBtn.disabled = true;
              addModelsCardBtn.style.display = 'flex';
              addModelsCount.textContent = `${unusedModels.length} kvar`;
              const dotColors = { gemini: '#10b981', anthropic: '#f59e0b', grok: '#3b82f6', openai: '#6b7280' };
              unusedModelDots.innerHTML = unusedModels.map(m => 
                `<span class="model-dot-unused" style="background: ${dotColors[m]}" title="${m}"></span>`
              ).join('');
              // Keep cards visible but hide deliberation if done
              deliberateNowBtn.style.display = hasRunDeliberation ? 'none' : 'flex';
            } else {
              // All models used - hide all cards
              nextStepCards.style.display = 'none';
            }
            
            // Update workflow progress
            updateWorkflowProgress();
            
            // Show save modal
            setTimeout(() => showSavePromptModal(), 500);
          }
          
          setStatus('', false);
        } catch (error) {
          showError('Syntesfel: ' + error.message + '. Försök igen.');
          setStatus('', false);
          // Re-enable synthesize button
          synthesizeNowBtn.disabled = false;
        } finally {
          setLoading(false);
        }
      });
      
      console.log('📌 Setting up runBtn listener...');
      if (!runBtn) {
        console.error('❌ runBtn not found!');
      } else {
        runBtn.addEventListener('click', () => {
          console.log('🔥 Run button clicked!');
          runQuery();
        });
        console.log('✅ runBtn listener attached');
      }
      document.addEventListener('keydown', (e) => { if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') runQuery(); });
      
      // Single model run buttons - run ONE model at a time for debugging
      document.querySelectorAll('.single-model-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
          const modelId = btn.dataset.model;
          const prompt = promptEl.value.trim();
          const context = contextEl.value.trim();
          
          if (!prompt) {
            showError('Ange en prompt först.');
            return;
          }
          
          // IMPORTANT: Save prompt for later synthesis
          currentPrompt = prompt;
          
          // Disable all single model buttons while running
          document.querySelectorAll('.single-model-btn').forEach(b => b.disabled = true);
          btn.classList.add('running');
          btn.textContent = '⏳ Kör...';
          
          const modelNames = { gemini: 'Gemini', anthropic: 'Claude', grok: 'Grok', openai: 'OpenAI' };
          setStatus(`🔄 Kör ${modelNames[modelId]}...`, true);
          hideError();
          
          // Show results section
          resultsEl.classList.add('visible');
          
          // Show and prepare the accordion for this model
          const providerMap = { gemini: 'google', anthropic: 'anthropic', grok: 'grok', openai: 'openai' };
          const providerId = providerMap[modelId];
          const accordion = document.getElementById('accordion-' + providerId);
          if (accordion) {
            accordion.style.display = 'block';
            document.getElementById('status-' + providerId).textContent = 'Kör...';
            document.getElementById('status-' + providerId).className = 'accordion-status waiting';
            document.getElementById('duration-' + providerId).textContent = '';
          }
          
          try {
            console.log(`🚀 Running single model: ${modelId}`);
            const startTime = Date.now();
            
            const response = await fetch('/api/ai-council/query', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                context,
                prompt,
                selectedModels: [modelId],
                synthesisModel: 'gemini', // Cheapest for single model
                enableDeliberation: false,
                skipSynthesis: true, // No synthesis for single model runs
                profileType: 'fast'
              })
            });
            
            const duration = Date.now() - startTime;
            console.log(`📦 Response received in ${duration}ms, status: ${response.status}`);
            
            if (!response.ok) {
              const errorText = await response.text();
              console.error('API Error:', errorText.substring(0, 500));
              throw new Error(`HTTP ${response.status}: ${errorText.substring(0, 100)}`);
            }
            
            // Handle streaming response
            const contentType = response.headers.get('content-type') || '';
            let data = null;
            
            if (contentType.includes('text/plain') || contentType.includes('ndjson')) {
              const reader = response.body.getReader();
              const decoder = new TextDecoder();
              let buffer = '';
              
              while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                buffer += decoder.decode(value, { stream: true });
                
                const lines = buffer.split('\n');
                buffer = lines.pop() || '';
                
                for (const line of lines) {
                  if (!line.trim()) continue;
                  try {
                    const event = JSON.parse(line);
                    console.log('Event:', event.type, event.data);
                    if (event.type === 'model_complete') {
                      setStatus(`✓ ${modelNames[modelId]} svarade (${(event.data.duration/1000).toFixed(1)}s)`, true);
                    }
                    if (event.type === 'complete') data = event.data;
                    if (event.type === 'error') throw new Error(event.data.error);
                  } catch (e) {
                    if (e.message !== "Unexpected end of JSON input") {
                      console.warn('Parse error:', e);
                    }
                  }
                }
              }
            } else {
              const text = await response.text();
              if (text.startsWith('<')) {
                throw new Error('Server returnerade HTML (troligen timeout eller serverproblem)');
              }
              data = JSON.parse(text);
            }
            
            if (!data) throw new Error('Inget svar från API');
            
            // Process the response
            if (data.responses && data.responses.length > 0) {
              const r = data.responses[0];
              if (r.error) {
                showError(`${modelNames[modelId]} fel: ${r.error}`);
                document.getElementById('status-' + providerId).textContent = 'Fel';
                document.getElementById('status-' + providerId).className = 'accordion-status error';
              } else {
                // Success! Display and store the response
                displayResponse(providerId, r);
                collectedResponses[modelId] = r;
                saveResponsesToStorage(); // Persist immediately!
                
                document.getElementById('status-' + providerId).textContent = '✓';
                document.getElementById('status-' + providerId).className = 'accordion-status success';
                document.getElementById('duration-' + providerId).textContent = formatDuration(r.duration);
                
                // Open the accordion to show the response
                accordion.classList.add('open');
                
                setStatus(`✓ ${modelNames[modelId]} klar! (${Object.keys(collectedResponses).length} svar totalt)`, true);
                
                // Mark button as done
                btn.classList.add('done');
                
                // Play success sound
                playNotificationSound('success');
              }
            }
            
            // Update workflow progress
            updateWorkflowProgress();
            
            // Show next step cards if we have responses
            const respCount = Object.keys(collectedResponses).length;
            if (respCount > 0) {
              nextStepCards.style.display = 'block';
              synthesizeNowBtn.disabled = false;
              synthesizeCount.textContent = hasRunDeliberation ? `${respCount}+R2 svar` : `${respCount} svar`;
              
              if (respCount >= 2 && !hasRunDeliberation) {
                deliberateNowBtn.disabled = false;
                deliberateCount.textContent = `${respCount} svar`;
                const singleDelibSection = document.getElementById('singleDeliberationSection');
                if (singleDelibSection) singleDelibSection.style.display = 'block';
              }
            }
            
          } catch (error) {
            console.error('Single model error:', error);
            showError(`${modelNames[modelId]} fel: ${error.message}`);
            playNotificationSound('error');
            if (accordion) {
              document.getElementById('status-' + providerId).textContent = 'Fel';
              document.getElementById('status-' + providerId).className = 'accordion-status error';
            }
          } finally {
            // Re-enable buttons
            document.querySelectorAll('.single-model-btn').forEach(b => {
              b.disabled = false;
              b.classList.remove('running');
            });
            // Restore button texts
            const btnTexts = { gemini: 'Gemini', anthropic: 'Claude', grok: 'Grok', openai: 'OpenAI' };
            document.querySelectorAll('.single-model-btn').forEach(b => {
              const dot = b.querySelector('span');
              b.innerHTML = '';
              b.appendChild(dot);
              b.appendChild(document.createTextNode(' ' + btnTexts[b.dataset.model]));
            });
            setTimeout(() => setStatus('', false), 3000);
          }
        });
      });
      
      // ============================================
      // SEQUENTIAL RUN - Run all selected models one by one
      // ============================================
      const runAllSequentialBtn = document.getElementById('runAllSequentialBtn');
      
      runAllSequentialBtn.addEventListener('click', async () => {
        const prompt = promptEl.value.trim();
        const context = contextEl.value.trim();
        
        if (!prompt) {
          showError('Ange en prompt först.');
          return;
        }
        
        // Get selected models from checkboxes
        const selectedModels = [];
        document.querySelectorAll('#modelSelection .model-checkbox input:checked').forEach(cb => {
          const modelEl = cb.closest('.model-checkbox');
          if (modelEl) {
            const model = modelEl.dataset.model;
            // Skip models that already have responses
            if (model && !collectedResponses[model === 'gemini' ? 'google' : model]) {
              selectedModels.push(model);
            }
          }
        });
        
        if (selectedModels.length === 0) {
          showError('Välj minst en modell att köra, eller alla valda modeller har redan svar.');
          return;
        }
        
        // IMPORTANT: Save prompt for later synthesis
        currentPrompt = prompt;
        
        isRunningSequential = true;
        runAllSequentialBtn.disabled = true;
        runAllSequentialBtn.classList.add('running');
        runAllSequentialBtn.textContent = `⏳ Kör ${selectedModels.length} modeller...`;
        
        // Disable individual buttons during sequential run
        document.querySelectorAll('.single-model-btn').forEach(b => b.disabled = true);
        
        const modelNames = { gemini: 'Gemini', anthropic: 'Claude', grok: 'Grok', openai: 'OpenAI' };
        const providerMap = { gemini: 'google', anthropic: 'anthropic', grok: 'grok', openai: 'openai' };
        
        // Show results section
        resultsEl.classList.add('visible');
        
        let completedCount = 0;
        let errorCount = 0;
        
        for (const modelId of selectedModels) {
          const providerId = providerMap[modelId];
          
          // Update status
          setStatus(`🔄 Kör ${modelNames[modelId]} (${completedCount + 1}/${selectedModels.length})...`, true);
          runAllSequentialBtn.textContent = `⏳ ${modelNames[modelId]} (${completedCount + 1}/${selectedModels.length})`;
          
          // Show and prepare the accordion
          const accordion = document.getElementById('accordion-' + providerId);
          if (accordion) {
            accordion.style.display = 'block';
            document.getElementById('status-' + providerId).textContent = 'Kör...';
            document.getElementById('status-' + providerId).className = 'accordion-status waiting';
            document.getElementById('duration-' + providerId).textContent = '0.0s';
          }
          
          // Mark button as running
          const btn = document.querySelector(`.single-model-btn[data-model="${modelId}"]`);
          if (btn) btn.classList.add('running');
          
          try {
            console.log(`🚀 Sequential: Running ${modelId}`);
            
            const response = await fetch('/api/ai-council/query', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                context,
                prompt,
                selectedModels: [modelId],
                synthesisModel: 'gemini',
                enableDeliberation: false,
                skipSynthesis: true,
              })
            });
            
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.responses && data.responses.length > 0) {
              const r = data.responses[0];
              collectedResponses[providerId] = r;
              displayResponse(providerId, r);
              
              if (accordion) {
                document.getElementById('status-' + providerId).textContent = '✓';
                document.getElementById('status-' + providerId).className = 'accordion-status success';
                document.getElementById('duration-' + providerId).textContent = formatDuration(r.duration);
                accordion.classList.add('open');
              }
              
              if (btn) {
                btn.classList.remove('running');
                btn.classList.add('done');
              }
              
              completedCount++;
              playNotificationSound('success');
              
              // Save progress
              saveResponsesToStorage();
            }
            
          } catch (error) {
            console.error(`Sequential error for ${modelId}:`, error);
            errorCount++;
            playNotificationSound('error');
            
            if (accordion) {
              document.getElementById('status-' + providerId).textContent = 'Fel';
              document.getElementById('status-' + providerId).className = 'accordion-status error';
            }
            if (btn) btn.classList.remove('running');
            
            // Continue to next model despite error
          }
          
          // Small delay between models
          await new Promise(resolve => setTimeout(resolve, 500));
        }
        
        // All done
        isRunningSequential = false;
        runAllSequentialBtn.disabled = false;
        runAllSequentialBtn.classList.remove('running');
        runAllSequentialBtn.textContent = '▶️ Kör alla i sekvens';
        
        // Re-enable individual buttons
        document.querySelectorAll('.single-model-btn').forEach(b => {
          b.disabled = false;
          b.classList.remove('running');
        });
        
        // Update workflow progress
        updateWorkflowProgress();
        
        // Show next step cards
        const responseCount = Object.keys(collectedResponses).length;
        if (responseCount > 0) {
          nextStepCards.style.display = 'block';
          synthesizeNowBtn.disabled = false;
          synthesizeCount.textContent = hasRunDeliberation ? `${responseCount}+R2 svar` : `${responseCount} svar`;
          
          if (responseCount >= 2 && !hasRunDeliberation) {
            deliberateNowBtn.disabled = false;
            deliberateCount.textContent = `${responseCount} svar`;
            const singleDelibSection = document.getElementById('singleDeliberationSection');
            if (singleDelibSection) singleDelibSection.style.display = 'block';
          }
        }
        
        // Play completion sound and show final status
        if (completedCount > 0) {
          playNotificationSound('complete');
          setStatus(`✅ Klart! ${completedCount}/${selectedModels.length} modeller lyckades${errorCount > 0 ? `, ${errorCount} fel` : ''}.`, true);
        } else {
          setStatus(`❌ Alla ${selectedModels.length} modeller misslyckades.`, true);
        }
        
        setTimeout(() => setStatus('', false), 5000);
      });
      
      // Hallucination details toggle
      document.getElementById('toggleHallucinationDetails').addEventListener('click', function() {
        const listEl = document.getElementById('hallucinationList');
        const isVisible = listEl.style.display !== 'none';
        listEl.style.display = isVisible ? 'none' : 'block';
        this.querySelector('span').textContent = isVisible ? '▼ Visa detaljer' : '▲ Dölj detaljer';
      });
      
      // =============================================
      // PROJECT SIDEBAR FUNCTIONALITY
      // =============================================
      
      const projectSidebar = document.getElementById('projectSidebar');
      const mobileMenuBtn = document.getElementById('mobileMenuBtn');
      const newChatBtn = document.getElementById('newChatBtn');
      const newProjectBtn = document.getElementById('newProjectBtn');
      const projectSearch = document.getElementById('projectSearch');
      const projectList = document.getElementById('projectList');
      // Session accordions
      const unsortedAccordion = document.getElementById('unsortedAccordion');
      const unsortedList = document.getElementById('unsortedList');
      const unsortedCount = document.getElementById('unsortedCount');
      const allSessionsAccordion = document.getElementById('allSessionsAccordion');
      const allSessionsList = document.getElementById('allSessionsList');
      const allSessionsCount = document.getElementById('allSessionsCount');
      
      // Zotero integration - Modal elements
      const zoteroOpenBtn = document.getElementById('zoteroOpenBtn');
      const zoteroStatus = document.getElementById('zoteroStatus');
      const zoteroModal = document.getElementById('zoteroModal');
      const zoteroModalClose = document.getElementById('zoteroModalClose');
      const zoteroModalUser = document.getElementById('zoteroModalUser');
      const zoteroCollectionsList = document.getElementById('zoteroCollectionsList');
      const zoteroModalSearch = document.getElementById('zoteroModalSearch');
      const zoteroModalSearchBtn = document.getElementById('zoteroModalSearchBtn');
      const zoteroModalResults = document.getElementById('zoteroModalResults');
      const zoteroResultsCount = document.getElementById('zoteroResultsCount');
      const zoteroSelectAll = document.getElementById('zoteroSelectAll');
      const zoteroSelectedInfo = document.getElementById('zoteroSelectedInfo');
      const zoteroImportSelectedBtn = document.getElementById('zoteroImportSelectedBtn');
      const zoteroDisconnectBtn = document.getElementById('zoteroDisconnectBtn');
      const zoteroRefreshCollections = document.getElementById('zoteroRefreshCollections');
      const zoteroSetDefault = document.getElementById('zoteroSetDefault');
      
      // Zotero config modal elements
      const zoteroConfigModal = document.getElementById('zoteroConfigModal');
      const zoteroConfigClose = document.getElementById('zoteroConfigClose');
      const zoteroApiKeyInput = document.getElementById('zoteroApiKeyInput');
      const zoteroConfigSave = document.getElementById('zoteroConfigSave');
      const zoteroConfigCancel = document.getElementById('zoteroConfigCancel');
      
      let zoteroConfigured = false;
      let zoteroConfig = null;
      let zoteroCollections = [];
      let currentCollection = null;
      let selectedZoteroItems = new Set();
      
      let projects = [];
      let currentProjectId = null; // null = "Osorterade"
      
      // Toggle mobile sidebar
      mobileMenuBtn?.addEventListener('click', () => {
        projectSidebar.classList.toggle('open');
        mobileOverlay.classList.toggle('active', projectSidebar.classList.contains('open'));
      });
      
      // Mobile FAB for notes sidebar
      const mobileNotesFab = document.getElementById('mobileNotesFab');
      const mobileNotesBadge = document.getElementById('mobileNotesBadge');
      
      // Create mobile overlay if it doesn't exist
      let mobileOverlay = document.querySelector('.mobile-overlay');
      if (!mobileOverlay) {
        mobileOverlay = document.createElement('div');
        mobileOverlay.className = 'mobile-overlay';
        document.body.appendChild(mobileOverlay);
      }
      
      // Update badge count
      function updateNotesBadge() {
        const count = sessions.length;
        mobileNotesBadge.textContent = count;
        mobileNotesBadge.dataset.count = count;
      }
      
      // FAB click handler
      mobileNotesFab?.addEventListener('click', () => {
        notesSidebar.classList.add('open');
        notesSidebar.classList.remove('collapsed');
        mobileOverlay.classList.add('active');
      });
      
      // Close sidebar when clicking overlay
      mobileOverlay?.addEventListener('click', () => {
        projectSidebar.classList.remove('open');
        notesSidebar.classList.remove('open');
        mobileOverlay.classList.remove('active');
      });
      
      // Close sidebar when clicking outside on mobile
      document.addEventListener('click', (e) => {
        if (window.innerWidth <= 1024 && 
            projectSidebar.classList.contains('open') && 
            !projectSidebar.contains(e.target) && 
            e.target !== mobileMenuBtn &&
            !mobileOverlay.contains(e.target)) {
          projectSidebar.classList.remove('open');
          mobileOverlay.classList.remove('active');
        }
      });
      
      // New chat button - clear everything
      newChatBtn?.addEventListener('click', () => {
        // Clear form inputs
        contextEl.value = '';
        promptEl.value = '';
        
        // Clear uploaded files
        uploadedFiles = [];
        document.getElementById('fileList').innerHTML = '';
        
        // Reset all workflow state (collectedResponses, hasSynthesized, etc.)
        resetWorkflow();
        
        // Hide results and synthesis
        resultsEl.classList.remove('visible');
        synthesisCard.style.display = 'none';
        document.getElementById('synthesisContent').innerHTML = '';
        document.getElementById('costBanner').classList.remove('visible');
        
        // Clear current state
        currentPrompt = '';
        currentResponses = {};
        currentSessionId = null;
        
        // Hide all accordions
        document.querySelectorAll('.result-accordion').forEach(acc => {
          acc.style.display = 'none';
        });
        
        // Clear status
        setStatus('', false);
        hideError();
        
        // Close mobile sidebar
        if (window.innerWidth <= 1024) {
          projectSidebar.classList.remove('open');
        }
        
        console.log('🗑️ New chat - all state cleared');
      });
      
      // New project button
      newProjectBtn?.addEventListener('click', async () => {
        const name = prompt('Projektnamn:');
        if (!name) return;
        
        const description = prompt('Beskrivning (valfritt):') || '';
        const context = prompt('Automatisk kontext för alla frågor (valfritt):') || '';
        
        try {
          const res = await fetch('/api/ai-council/projects', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({ name, description, context })
          });
          
          if (res.ok) {
            const data = await res.json();
            if (data.project) {
              projects.unshift(data.project);
              renderProjects();
              selectProject(data.project.id);
            }
          } else {
            console.error('Failed to create project');
          }
        } catch (err) {
          console.error('Error creating project:', err);
        }
      });
      
      // Load projects
      async function loadProjects() {
        try {
          const res = await fetch('/api/ai-council/projects', { credentials: 'include' });
          if (res.ok) {
            const data = await res.json();
            projects = data.projects || [];
            renderProjects();
          }
        } catch (err) {
          console.error('Error loading projects:', err);
        }
      }
      
      // Render projects in sidebar
      function renderProjects() {
        const pinnedProjects = projects.filter(p => p.is_pinned);
        const recentProjects = projects.filter(p => !p.is_pinned).slice(0, 5);
        
        let html = '';
        
        // Pinned projects
        pinnedProjects.forEach(p => {
          html += `
            <div class="project-item ${currentProjectId === p.id ? 'active' : ''}" data-project-id="${p.id}">
              <span class="project-item-icon">${p.icon || '📁'}</span>
              <div class="project-item-info">
                <div class="project-item-name">${escapeHtml(p.name)}</div>
                <div class="project-item-count">${p.description || ''}</div>
              </div>
              <button class="project-item-pin pinned" title="Ta bort markering">📌</button>
            </div>
          `;
        });
        
        // Recent projects (non-pinned)
        recentProjects.forEach(p => {
          html += `
            <div class="project-item ${currentProjectId === p.id ? 'active' : ''}" data-project-id="${p.id}">
              <span class="project-item-icon">${p.icon || '📁'}</span>
              <div class="project-item-info">
                <div class="project-item-name">${escapeHtml(p.name)}</div>
                <div class="project-item-count">${p.description || ''}</div>
              </div>
              <button class="project-item-pin" title="Fäst projekt">📌</button>
            </div>
          `;
        });
        
        // Show empty state if no projects
        if (!html) {
          html = '<div class="session-empty" style="padding: 0.75rem 1.25rem;">Inga projekt ännu. Klicka 📁+ för att skapa.</div>';
        }
        
        projectList.innerHTML = html;
        
        // Add click handlers
        projectList.querySelectorAll('.project-item').forEach(item => {
          item.addEventListener('click', (e) => {
            if (e.target.classList.contains('project-item-pin')) return;
            selectProject(item.dataset.projectId || null);
          });
        });
        
        // Pin/unpin handlers
        projectList.querySelectorAll('.project-item-pin').forEach(btn => {
          btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const projectId = btn.closest('.project-item').dataset.projectId;
            const project = projects.find(p => p.id === projectId);
            if (project) {
              project.is_pinned = !project.is_pinned;
              renderProjects();
              // Update in backend
              try {
                await fetch('/api/ai-council/projects', {
                  method: 'PUT',
                  headers: { 'Content-Type': 'application/json' },
                  credentials: 'include',
                  body: JSON.stringify({ id: projectId, is_pinned: project.is_pinned })
                });
              } catch (err) {
                console.error('Error updating project:', err);
              }
            }
          });
        });
      }
      
      // Select a project
      function selectProject(projectId) {
        currentProjectId = projectId;
        
        // Update active state
        projectList.querySelectorAll('.project-item').forEach(item => {
          item.classList.toggle('active', (item.dataset.projectId || null) === projectId);
        });
        
        // If project has auto-context, add it to context field
        if (projectId) {
          const project = projects.find(p => p.id === projectId);
          if (project && project.context) {
            // Prepend project context if not already there
            if (!contextEl.value.includes('<!-- PROJECT CONTEXT -->')) {
              contextEl.value = '<!-- PROJECT CONTEXT -->\n' + project.context + '\n<!-- END PROJECT CONTEXT -->\n\n' + contextEl.value;
            }
          }
        }
        
        // Filter history by project
        loadHistoryForProject(projectId);
        
        // Close mobile sidebar
        if (window.innerWidth <= 1024) {
          projectSidebar.classList.remove('open');
        }
      }
      
      // Session accordion toggles
      unsortedAccordion?.querySelector('.session-accordion-header')?.addEventListener('click', () => {
        unsortedAccordion.classList.toggle('open');
      });
      allSessionsAccordion?.querySelector('.session-accordion-header')?.addEventListener('click', () => {
        allSessionsAccordion.classList.toggle('open');
      });
      // Zotero button opens modal
      zoteroOpenBtn?.addEventListener('click', async () => {
        // Always check configuration status first
        const isConfigured = await checkZoteroConfig();
        
        if (zoteroStatus.textContent === '🔒') {
          // Authentication error - show message
          alert('Du måste vara inloggad för att använda Zotero.\n\nOm du ser detta meddelande, prova att logga ut och logga in igen.');
          return;
        }
        
        if (zoteroStatus.textContent === '⚠️') {
          // Error checking config
          alert('Kunde inte kontrollera Zotero-status.\n\nKontrollera din internetanslutning och försök igen.');
          return;
        }
        
        if (zoteroConfigured) {
          openZoteroModal();
        } else {
          openZoteroConfigModal();
        }
      });
      
      // Render session accordions
      function renderSessionAccordions() {
        // Unsorted sessions (no project_id)
        const unsortedSessions = sessions.filter(s => !s.project_id);
        // All sessions
        const allSessions = sessions;
        
        // Update counts
        if (unsortedCount) unsortedCount.textContent = unsortedSessions.length;
        if (allSessionsCount) allSessionsCount.textContent = allSessions.length;
        
        // Render unsorted sessions
        if (unsortedList) {
          unsortedList.innerHTML = unsortedSessions.length > 0 
            ? unsortedSessions.slice(0, 15).map(s => `
                <div class="session-item" data-session-id="${s.id}">
                  <span class="session-item-icon">💬</span>
                  <div class="session-item-info">
                    <div class="session-item-name">${escapeHtml(s.name || s.prompt?.substring(0, 40) || 'Utan titel')}</div>
                    <div class="session-item-meta">${new Date(s.created_at).toLocaleDateString('sv-SE')}</div>
                  </div>
                </div>
              `).join('')
            : '<div class="session-empty">Inga osorterade sessioner</div>';
          
          // Add click handlers
          unsortedList.querySelectorAll('.session-item').forEach(item => {
            item.addEventListener('click', () => {
              const session = sessions.find(s => s.id === item.dataset.sessionId);
              if (session) {
                openSession(session);
                if (window.innerWidth <= 1024) {
                  projectSidebar.classList.remove('open');
                }
              }
            });
          });
        }
        
        // Render all sessions
        if (allSessionsList) {
          allSessionsList.innerHTML = allSessions.length > 0 
            ? allSessions.slice(0, 15).map(s => `
                <div class="session-item" data-session-id="${s.id}">
                  <span class="session-item-icon">💬</span>
                  <div class="session-item-info">
                    <div class="session-item-name">${escapeHtml(s.name || s.prompt?.substring(0, 40) || 'Utan titel')}</div>
                    <div class="session-item-meta">${new Date(s.created_at).toLocaleDateString('sv-SE')}</div>
                  </div>
                </div>
              `).join('')
            : '<div class="session-empty">Inga sessioner ännu</div>';
          
          // Add click handlers
          allSessionsList.querySelectorAll('.session-item').forEach(item => {
            item.addEventListener('click', () => {
              const session = sessions.find(s => s.id === item.dataset.sessionId);
              if (session) {
                openSession(session);
                if (window.innerWidth <= 1024) {
                  projectSidebar.classList.remove('open');
                }
              }
            });
          });
        }
      }
      
      // Load history for a project (now primarily updates project selection UI)
      async function loadHistoryForProject(projectId) {
        // Re-render session accordions when project changes
        renderSessionAccordions();
      }
      
      // Search functionality
      let searchTimeout;
      projectSearch?.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
          const query = e.target.value.toLowerCase();
          if (query) {
            const filtered = sessions.filter(s => 
              (s.name || '').toLowerCase().includes(query) ||
              (s.prompt || '').toLowerCase().includes(query)
            );
            
            // Show search results in the all sessions accordion
            if (allSessionsList) {
              allSessionsList.innerHTML = filtered.length > 0 
                ? filtered.slice(0, 20).map(s => `
                    <div class="session-item" data-session-id="${s.id}">
                      <span class="session-item-icon">💬</span>
                      <div class="session-item-info">
                        <div class="session-item-name">${escapeHtml(s.name || s.prompt?.substring(0, 40) || 'Utan titel')}</div>
                        <div class="session-item-meta">${new Date(s.created_at).toLocaleDateString('sv-SE')}</div>
                      </div>
                    </div>
                  `).join('')
                : '<div class="session-empty">Inga resultat</div>';
              
              // Update count to show filtered results
              if (allSessionsCount) allSessionsCount.textContent = filtered.length;
              
              // Add click handlers for search results
              allSessionsList.querySelectorAll('.session-item').forEach(item => {
                item.addEventListener('click', () => {
                  const session = sessions.find(s => s.id === item.dataset.sessionId);
                  if (session) {
                    openSession(session);
                    if (window.innerWidth <= 1024) {
                      projectSidebar.classList.remove('open');
                    }
                  }
                });
              });
              
              // Open all sessions accordion if closed
              if (!allSessionsAccordion.classList.contains('open')) {
                allSessionsAccordion.classList.add('open');
              }
            }
          } else {
            // Reset to normal view
            renderSessionAccordions();
          }
        }, 300);
      });
      
      // Helper function for escaping HTML
      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
      
      // =============================================
      // CONTEXT MENU FUNCTIONALITY
      // =============================================
      
      const contextMenu = document.getElementById('projectContextMenu');
      const colorPickerModal = document.getElementById('colorPickerModal');
      const iconPickerModal = document.getElementById('iconPickerModal');
      let contextMenuProjectId = null;
      
      // Right-click on project items
      projectList.addEventListener('contextmenu', (e) => {
        const projectItem = e.target.closest('.project-item');
        if (!projectItem || !projectItem.dataset.projectId) return;
        
        e.preventDefault();
        contextMenuProjectId = projectItem.dataset.projectId;
        
        // Position the menu
        contextMenu.style.left = e.clientX + 'px';
        contextMenu.style.top = e.clientY + 'px';
        contextMenu.classList.add('open');
      });
      
      // Close context menu when clicking elsewhere
      document.addEventListener('click', (e) => {
        if (!contextMenu.contains(e.target)) {
          contextMenu.classList.remove('open');
        }
      });
      
      // Context menu actions
      contextMenu.querySelectorAll('.context-menu-item').forEach(item => {
        item.addEventListener('click', async () => {
          const action = item.dataset.action;
          const project = projects.find(p => p.id === contextMenuProjectId);
          if (!project && action !== 'delete') return;
          
          contextMenu.classList.remove('open');
          
          switch (action) {
            case 'edit':
              const newName = prompt('Nytt namn:', project.name);
              if (newName && newName !== project.name) {
                await updateProject(contextMenuProjectId, { name: newName });
              }
              break;
              
            case 'context':
              const newContext = prompt('Automatisk kontext för alla frågor:', project.context || '');
              if (newContext !== null) {
                await updateProject(contextMenuProjectId, { context: newContext });
              }
              break;
              
            case 'color':
              // Mark current color as selected
              colorPickerModal.querySelectorAll('.color-picker-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.color === project.color);
              });
              colorPickerModal.classList.add('open');
              break;
              
            case 'icon':
              // Mark current icon as selected
              iconPickerModal.querySelectorAll('.icon-picker-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.icon === project.icon);
              });
              iconPickerModal.classList.add('open');
              break;
              
            case 'pin':
              await updateProject(contextMenuProjectId, { is_pinned: !project.is_pinned });
              break;
              
            case 'delete':
              if (confirm('Är du säker på att du vill ta bort projektet? Sessioner flyttas till "Osorterade".')) {
                await deleteProject(contextMenuProjectId);
              }
              break;
          }
        });
      });
      
      // Color picker
      colorPickerModal.querySelectorAll('.color-picker-option').forEach(opt => {
        opt.addEventListener('click', async () => {
          const color = opt.dataset.color;
          await updateProject(contextMenuProjectId, { color });
          colorPickerModal.classList.remove('open');
        });
      });
      document.getElementById('closeColorPicker').addEventListener('click', () => {
        colorPickerModal.classList.remove('open');
      });
      
      // Icon picker
      iconPickerModal.querySelectorAll('.icon-picker-option').forEach(opt => {
        opt.addEventListener('click', async () => {
          const icon = opt.dataset.icon;
          await updateProject(contextMenuProjectId, { icon });
          iconPickerModal.classList.remove('open');
        });
      });
      document.getElementById('closeIconPicker').addEventListener('click', () => {
        iconPickerModal.classList.remove('open');
      });
      
      // Update project helper
      async function updateProject(projectId, data) {
        try {
          const res = await fetch('/api/ai-council/projects', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({ id: projectId, ...data })
          });
          
          if (res.ok) {
            const result = await res.json();
            if (result.project) {
              const idx = projects.findIndex(p => p.id === projectId);
              if (idx !== -1) {
                projects[idx] = result.project;
                renderProjects();
              }
            }
          }
        } catch (err) {
          console.error('Error updating project:', err);
        }
      }
      
      // Delete project helper
      async function deleteProject(projectId) {
        try {
          const res = await fetch('/api/ai-council/projects?id=' + projectId, {
            method: 'DELETE',
            credentials: 'include'
          });
          
          if (res.ok) {
            projects = projects.filter(p => p.id !== projectId);
            if (currentProjectId === projectId) {
              selectProject(null);
            }
            renderProjects();
          }
        } catch (err) {
          console.error('Error deleting project:', err);
        }
      }
      
      // Load projects on page load
      loadProjects();
      
      // Update session accordions when sessions change
      const originalLoadSessions = loadSessions;
      loadSessions = async function() {
        await originalLoadSessions.call(this);
        renderSessionAccordions();
      };
      
      // =============================================
      // ZOTERO INTEGRATION (Modal-based)
      // =============================================
      
      // Check if Zotero is configured
      async function checkZoteroConfig() {
        try {
          const response = await fetch('/api/ai-council/zotero/validate');
          const data = await response.json();
          
          if (response.status === 401) {
            // Not logged in
            console.warn('Not authenticated for Zotero');
            zoteroStatus.textContent = '🔒';
            zoteroStatus.title = 'Logga in för att använda Zotero';
            return false;
          }
          
          if (data.configured) {
            zoteroConfigured = true;
            zoteroConfig = data.config;
            zoteroStatus.textContent = '✓';
            zoteroStatus.classList.add('configured');
            return true;
          } else {
            zoteroConfigured = false;
            zoteroStatus.textContent = '—';
            zoteroStatus.classList.remove('configured');
            return false;
          }
        } catch (error) {
          console.error('Zotero config check error:', error);
          zoteroStatus.textContent = '⚠️';
          return false;
        }
      }
      
      // Open config modal
      function openZoteroConfigModal() {
        zoteroApiKeyInput.value = '';
        zoteroConfigModal.classList.add('open');
      }
      
      // Close config modal
      zoteroConfigClose?.addEventListener('click', () => zoteroConfigModal.classList.remove('open'));
      zoteroConfigCancel?.addEventListener('click', () => zoteroConfigModal.classList.remove('open'));
      
      // Save API key
      zoteroConfigSave?.addEventListener('click', async () => {
        const apiKey = zoteroApiKeyInput.value.trim();
        if (!apiKey) return;
        
        zoteroConfigSave.disabled = true;
        zoteroConfigSave.textContent = 'Validerar...';
        
        try {
          const response = await fetch('/api/ai-council/zotero/validate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ apiKey })
          });
          
          const data = await response.json();
          
          if (response.ok && data.success) {
            zoteroConfigured = true;
            zoteroConfig = data.config;
            zoteroStatus.textContent = '✓';
            zoteroStatus.classList.add('configured');
            zoteroConfigModal.classList.remove('open');
            openZoteroModal();
          } else {
            alert(data.message || 'Kunde inte validera API-nyckeln');
          }
        } catch (error) {
          console.error('Zotero save error:', error);
          alert('Ett fel uppstod. Försök igen.');
        } finally {
          zoteroConfigSave.disabled = false;
          zoteroConfigSave.textContent = '🔑 Spara';
        }
      });
      
      // Open main Zotero modal
      function openZoteroModal() {
        zoteroModal.classList.add('open');
        zoteroModalUser.textContent = zoteroConfig?.username || '';
        selectedZoteroItems.clear();
        updateZoteroSelection();
        zoteroModalResults.innerHTML = `
          <div class="zotero-empty">
            <div class="zotero-empty-icon">📂</div>
            <p>Välj en collection eller sök i hela biblioteket</p>
          </div>
        `;
        loadZoteroCollections();
      }
      
      // Close main modal
      zoteroModalClose?.addEventListener('click', () => zoteroModal.classList.remove('open'));
      zoteroModal?.addEventListener('click', (e) => {
        if (e.target === zoteroModal) zoteroModal.classList.remove('open');
      });
      
      // Load collections
      async function loadZoteroCollections() {
        zoteroCollectionsList.innerHTML = '<div class="zotero-loading">Laddar collections...</div>';
        
        try {
          const response = await fetch('/api/ai-council/zotero/collections');
          const data = await response.json();
          
          if (!response.ok) {
            throw new Error(data.message || 'Kunde inte hämta collections');
          }
          
          // Build tree structure from flat list
          const allCollections = [...(data.collections || [])];
          Object.values(data.subCollections || {}).forEach(subs => {
            allCollections.push(...subs);
          });
          
          // Create lookup map
          const collectionMap = new Map();
          allCollections.forEach(c => collectionMap.set(c.key, c));
          
          // Build parent-children map
          const childrenMap = new Map();
          allCollections.forEach(c => {
            if (c.parentKey) {
              const children = childrenMap.get(c.parentKey) || [];
              children.push(c);
              childrenMap.set(c.parentKey, children);
            }
          });
          
          // Recursive function to render collections
          function renderCollection(col, depth = 0) {
            const isActive = currentCollection === col.key;
            const isDefault = data.defaultCollection === col.key;
            const indent = depth * 1.25;
            const children = childrenMap.get(col.key) || [];
            const hasChildren = children.length > 0;
            
            let html = `
              <div class="zotero-collection-item ${isActive ? 'active' : ''}" data-key="${col.key}" style="padding-left: ${0.75 + indent}rem;">
                <span class="zotero-collection-icon">${hasChildren ? '📁' : '📄'}</span>
                <span class="zotero-collection-name">${escapeHtml(col.name)}${isDefault ? ' ⭐' : ''}</span>
                <span class="zotero-collection-count">${col.numItems}</span>
              </div>
            `;
            
            // Sort children alphabetically and render
            children.sort((a, b) => a.name.localeCompare(b.name, 'sv'));
            children.forEach(child => {
              html += renderCollection(child, depth + 1);
            });
            
            return html;
          }
          
          // Build HTML starting with library root
          let html = `
            <div class="zotero-collection-item library ${!currentCollection ? 'active' : ''}" data-key="">
              <span class="zotero-collection-icon">📚</span>
              <span class="zotero-collection-name">Mitt bibliotek</span>
            </div>
          `;
          
          // Get top-level collections (no parent)
          const topLevel = (data.collections || []).sort((a, b) => a.name.localeCompare(b.name, 'sv'));
          topLevel.forEach(col => {
            html += renderCollection(col, 1);
          });
          
          zoteroCollectionsList.innerHTML = html;
          
          // Add click handlers
          zoteroCollectionsList.querySelectorAll('.zotero-collection-item').forEach(el => {
            el.addEventListener('click', () => {
              const key = el.dataset.key;
              currentCollection = key || null;
              
              // Update active state
              document.querySelectorAll('.zotero-collection-item').forEach(e => e.classList.remove('active'));
              el.classList.add('active');
              
              // Update set default checkbox
              zoteroSetDefault.checked = data.defaultCollection === key;
              
              // Load items in this collection
              if (key) {
                searchZotero('');  // Empty search = browse collection
              } else {
                zoteroResultsCount.textContent = 'Sök eller välj en collection';
                zoteroModalResults.innerHTML = `
                  <div class="zotero-empty">
                    <div class="zotero-empty-icon">📂</div>
                    <p>Välj en collection eller sök i hela biblioteket</p>
                  </div>
                `;
              }
            });
          });
          
        } catch (error) {
          console.error('Failed to load collections:', error);
          zoteroCollectionsList.innerHTML = `
            <div class="zotero-error">
              ${escapeHtml(error.message || 'Kunde inte ladda collections')}
              <br><small>Kontrollera att du är inloggad och att API-nyckeln är giltig.</small>
            </div>
          `;
        }
      }
      
      // Search in Zotero
      async function searchZotero(query) {
        zoteroModalResults.innerHTML = '<div class="zotero-loading">Söker...</div>';
        
        try {
          const params = new URLSearchParams({ limit: '25' });
          if (query) params.set('q', query);
          if (currentCollection) params.set('collection', currentCollection);
          
          const response = await fetch(`/api/ai-council/zotero/search?${params}`);
          const data = await response.json();
          
          if (!response.ok) throw new Error(data.message || 'Sökningen misslyckades');
          
          if (data.items.length === 0) {
            zoteroModalResults.innerHTML = `
              <div class="zotero-empty">
                <div class="zotero-empty-icon">📭</div>
                <p>Inga resultat hittades</p>
              </div>
            `;
            zoteroResultsCount.textContent = '0 resultat';
          } else {
            zoteroResultsCount.textContent = `${data.totalResults} resultat`;
            renderZoteroResults(data.items);
          }
        } catch (error) {
          console.error('Zotero search error:', error);
          zoteroModalResults.innerHTML = `<div class="zotero-error">${escapeHtml(error.message)}</div>`;
        }
      }
      
      // Render results
      function renderZoteroResults(items) {
        zoteroModalResults.innerHTML = items.map(item => `
          <div class="zotero-result-item ${selectedZoteroItems.has(item.key) ? 'selected' : ''}" data-key="${item.key}">
            <input type="checkbox" class="zotero-result-checkbox" data-key="${item.key}" 
              ${selectedZoteroItems.has(item.key) ? 'checked' : ''}>
            <div class="zotero-result-info">
              <div class="zotero-result-title">${escapeHtml(item.title)}</div>
              <div class="zotero-result-meta">${escapeHtml(item.authors)} ${item.year ? '(' + item.year + ')' : ''}</div>
              ${item.journal ? `<div class="zotero-result-journal">${escapeHtml(item.journal)}</div>` : ''}
              <div style="display: flex; gap: 0.5rem; align-items: center; margin-top: 0.375rem;">
                ${item.hasPdf ? '<span class="zotero-result-pdf">📄 PDF</span>' : ''}
                ${item.tags.length > 0 ? `
                  <div class="zotero-result-tags">
                    ${item.tags.slice(0, 4).map(t => `<span class="zotero-result-tag">${escapeHtml(t)}</span>`).join('')}
                  </div>
                ` : ''}
              </div>
            </div>
          </div>
        `).join('');
        
        // Add click handlers
        zoteroModalResults.querySelectorAll('.zotero-result-item').forEach(el => {
          el.addEventListener('click', (e) => {
            if (e.target.type !== 'checkbox') {
              const checkbox = el.querySelector('.zotero-result-checkbox');
              checkbox.checked = !checkbox.checked;
            }
            const key = el.dataset.key;
            if (el.querySelector('.zotero-result-checkbox').checked) {
              selectedZoteroItems.add(key);
              el.classList.add('selected');
            } else {
              selectedZoteroItems.delete(key);
              el.classList.remove('selected');
            }
            updateZoteroSelection();
          });
        });
      }
      
      // Update selection info
      function updateZoteroSelection() {
        const count = selectedZoteroItems.size;
        zoteroSelectedInfo.textContent = `${count} valda`;
        zoteroImportSelectedBtn.disabled = count === 0;
        zoteroSelectAll.checked = count > 0 && 
          zoteroModalResults.querySelectorAll('.zotero-result-checkbox').length === count;
      }
      
      // Search button click
      zoteroModalSearchBtn?.addEventListener('click', () => {
        searchZotero(zoteroModalSearch.value.trim());
      });
      zoteroModalSearch?.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') searchZotero(zoteroModalSearch.value.trim());
      });
      
      // Select all
      zoteroSelectAll?.addEventListener('change', () => {
        const checkboxes = zoteroModalResults.querySelectorAll('.zotero-result-checkbox');
        checkboxes.forEach(cb => {
          cb.checked = zoteroSelectAll.checked;
          const item = cb.closest('.zotero-result-item');
          if (zoteroSelectAll.checked) {
            selectedZoteroItems.add(cb.dataset.key);
            item.classList.add('selected');
          } else {
            selectedZoteroItems.delete(cb.dataset.key);
            item.classList.remove('selected');
          }
        });
        updateZoteroSelection();
      });
      
      // Import selected PDFs
      zoteroImportSelectedBtn?.addEventListener('click', async () => {
        if (selectedZoteroItems.size === 0) return;
        
        zoteroImportSelectedBtn.disabled = true;
        zoteroImportSelectedBtn.textContent = 'Importerar...';
        
        let importedCount = 0;
        let importedText = '';
        
        for (const itemKey of selectedZoteroItems) {
          try {
            const response = await fetch('/api/ai-council/zotero/fetch-pdf', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ itemKey })
            });
            
            const data = await response.json();
            
            if (response.ok && data.success && data.pdf.textContent) {
              const pdfText = data.pdf.textContent;
              const filename = data.pdf.filename;
              
              importedText += `\n\n---\n\n📄 **${filename}** (från Zotero):\n\n${pdfText.slice(0, 30000)}${pdfText.length > 30000 ? '\n\n[...trunkerad...]' : ''}`;
              importedCount++;
            }
          } catch (error) {
            console.error('Import error for', itemKey, error);
          }
        }
        
        if (importedCount > 0 && contextEl) {
          contextEl.value = (contextEl.value.trim() ? contextEl.value : '') + importedText;
          alert(`✅ Importerade ${importedCount} PDF:er till kontexten`);
          zoteroModal.classList.remove('open');
        } else {
          alert('Kunde inte importera några PDF:er. Kontrollera att artiklarna har bifogade PDF-filer.');
        }
        
        zoteroImportSelectedBtn.disabled = false;
        zoteroImportSelectedBtn.textContent = '📥 Importera valda PDF:er';
      });
      
      // Disconnect Zotero
      zoteroDisconnectBtn?.addEventListener('click', async () => {
        if (!confirm('Vill du koppla från Zotero? Din API-nyckel kommer tas bort.')) return;
        
        try {
          await fetch('/api/ai-council/zotero/validate', { method: 'DELETE' });
          zoteroConfigured = false;
          zoteroConfig = null;
          zoteroStatus.textContent = '—';
          zoteroStatus.classList.remove('configured');
          zoteroModal.classList.remove('open');
        } catch (error) {
          console.error('Disconnect error:', error);
        }
      });
      
      // Refresh collections
      zoteroRefreshCollections?.addEventListener('click', loadZoteroCollections);
      
      // Check Zotero config on page load
      checkZoteroConfig();
      
      // =============================================
      // RESTORE SAVED RESPONSES ON PAGE LOAD
      // =============================================
      (async () => {
        // Check for Kunskapsbas project context from URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const kbProjectId = urlParams.get('kb_project');
        
        if (kbProjectId) {
          console.log('📚 Loading Kunskapsbas project context:', kbProjectId);
          try {
            const response = await fetch(`/api/kunskapsbas/context?project_id=${kbProjectId}`);
            const data = await response.json();
            
            if (data.context && data.project) {
              // Set the context in the textarea
              contextEl.value = data.context;
              
              // Show notification with token estimate
              const tokenStr = data.estimatedTokens > 1000 
                ? `${Math.round(data.estimatedTokens / 1000)}k tokens` 
                : `${data.estimatedTokens} tokens`;
              let statusMsg = `📚 "${data.project.name}" (${data.itemCount} dok, ~${tokenStr})`;
              if (data.isLarge) {
                statusMsg += ' ⚠️ Stor kontext - kan ta tid';
              }
              setStatus(statusMsg, true);
              setTimeout(() => setStatus('', false), 8000);
              
              console.log('✅ Kunskapsbas context loaded:', data.itemCount, 'items,', data.estimatedTokens, 'tokens');
            } else if (data.error) {
              console.warn('Could not load Kunskapsbas context:', data.error);
            }
          } catch (error) {
            console.error('Error loading Kunskapsbas context:', error);
          }
        }
        
        const hasRestoredResponses = await loadResponsesFromStorage();
        
        if (hasRestoredResponses) {
          console.log('📂 Found saved responses, restoring UI...');
          
          // Show results section
          resultsEl.classList.add('visible');
          
          // Display each saved response
          const providerMap = { gemini: 'google', anthropic: 'anthropic', grok: 'grok', openai: 'openai' };
          Object.entries(collectedResponses).forEach(([modelId, response]) => {
            const providerId = providerMap[modelId];
            const accordion = document.getElementById('accordion-' + providerId);
            if (accordion && response) {
              accordion.style.display = 'block';
              displayResponse(providerId, response);
              document.getElementById('status-' + providerId).textContent = '✓';
              document.getElementById('status-' + providerId).className = 'accordion-status success';
              if (response.duration) {
                document.getElementById('duration-' + providerId).textContent = formatDuration(response.duration);
              }
            }
          });
          
          // Update workflow progress
          updateWorkflowProgress();
          
          // Show next step cards
          const responseCount = Object.keys(collectedResponses).length;
          if (responseCount > 0) {
            nextStepCards.style.display = 'block';
            synthesizeNowBtn.disabled = false;
            synthesizeCount.textContent = `${responseCount} svar`;
            
            if (responseCount >= 2 && !hasRunDeliberation) {
              deliberateNowBtn.disabled = false;
              deliberateCount.textContent = `${responseCount} svar`;
              const singleDelibSection = document.getElementById('singleDeliberationSection');
              if (singleDelibSection) singleDelibSection.style.display = 'block';
            }
            
            // Show restore notification
            setStatus(`📂 Återställde ${responseCount} sparade svar från Supabase. Klicka "Börja om" för att rensa.`, true);
            setTimeout(() => setStatus('', false), 5000);
          }
        }
        
        console.log('✅ AI Council fully initialized');
      })();
      
      // =============================================
      // SAVE TO KUNSKAPSBAS
      // =============================================
      const saveToKBBtn = document.getElementById('saveToKB');
      
      if (saveToKBBtn) {
        saveToKBBtn.addEventListener('click', async () => {
          const synthesisContent = document.getElementById('synthesisContent');
          if (!synthesisContent || !synthesisContent.textContent.trim()) {
            alert('Ingen syntes att spara');
            return;
          }
          
          // Fetch available KB projects
          try {
            const projectsRes = await fetch('/api/kunskapsbas/projects');
            const projectsData = await projectsRes.json();
            
            if (!projectsData.projects || projectsData.projects.length === 0) {
              if (confirm('Du har inga projekt i Kunskapsbasen. Vill du skapa ett först?')) {
                window.open('/admin/kunskapsbas', '_blank');
              }
              return;
            }
            
            // Simple selection via prompt
            const projectList = projectsData.projects.map((p, i) => `${i + 1}. ${p.name}`).join('\n');
            const selection = prompt(`Välj projekt att spara till:\n\n${projectList}\n\nAnge nummer (1-${projectsData.projects.length}):`);
            
            if (!selection) return;
            
            const projectIndex = parseInt(selection) - 1;
            if (isNaN(projectIndex) || projectIndex < 0 || projectIndex >= projectsData.projects.length) {
              alert('Ogiltigt val');
              return;
            }
            
            const selectedProject = projectsData.projects[projectIndex];
            const title = prompt('Ange titel för AI-frågan:', currentPrompt?.substring(0, 50) || 'AI Council syntes');
            
            if (!title) return;
            
            // Save to KB
            const saveRes = await fetch('/api/kunskapsbas/items', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                project_id: selectedProject.id,
                category: 'ai_fragor',
                title: title,
                content: synthesisContent.innerHTML,
                summary: currentPrompt?.substring(0, 200)
              })
            });
            
            const saveData = await saveRes.json();
            
            if (saveData.error) {
              alert('Kunde inte spara: ' + saveData.error);
            } else {
              alert(`✅ Sparat till "${selectedProject.name}" → AI-frågor`);
            }
          } catch (err) {
            console.error('Error saving to KB:', err);
            alert('Ett fel uppstod vid sparande');
          }
        });
      }
    });
  </script>
</body>
</html>
